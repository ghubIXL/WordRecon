<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaze Stabilization Tool</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #e0f2f7; /* Light blue background */
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 10px; /* Reduced padding */
            box-sizing: border-box;
        }

        .controls-container {
            background-color: #ffffff;
            padding: 15px; /* Reduced padding */
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px; /* Reduced margin */
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px; /* Reduced gap */
            box-sizing: border-box;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px; /* Reduced gap */
            min-width: 150px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em; /* Slightly smaller font */
            text-align: center;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            background: #d1e7f0; /* Lighter blue for track */
            outline: none;
            opacity: 0.8;
            transition: opacity 0.2s;
            border-radius: 5px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #007bff; /* Blue thumb */
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        input[type="number"],
        input[type="color"],
        select,
        textarea { /* Added textarea */
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            text-align: center;
            width: 100px; /* Fixed width for number input */
            box-sizing: border-box;
        }
        select {
            width: 100%; /* Make select full width in its group */
            min-width: 100px;
        }
        textarea { /* Styles for textarea */
            width: 100%;
            min-width: 100px;
            max-width: 200px; /* Limit max width for text area */
            height: 60px;
            resize: vertical; /* Allow vertical resizing */
            text-align: left;
            padding: 8px;
        }


        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: none;
            width: 50px;
            height: 35px;
            padding: 0;
            border-radius: 8px;
            cursor: pointer;
            background-color: transparent; /* Ensure background is transparent */
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        input[type="color"]::-moz-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-moz-color-swatch {
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            width: 100%;
            justify-content: center;
        }

        button {
            padding: 12px 25px;
            font-size: 1.1em;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
            font-weight: bold;
        }

        button#startButton {
            background-color: #28a745; /* Green */
            color: white;
        }

        button#startButton:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
        }

        button#stopButton {
            background-color: #dc3545; /* Red */
            color: white;
        }

        button#stopButton:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
        }

        canvas {
            border: 2px solid #007bff;
            background-color: #f8fcfd; /* Default very light blue/white for canvas background, overridden by JS */
            display: block;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            max-width: 100%; /* Ensure responsiveness */
            height: auto; /* Maintain aspect ratio */
            flex-grow: 1; /* Allow canvas to take up available space */
        }

        .current-value {
            font-size: 0.85em; /* Slightly smaller font */
            color: #007bff;
            font-weight: bold;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #007bff;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls-container {
                flex-direction: column;
                align-items: stretch;
                padding: 10px;
                gap: 10px;
            }
            .control-group {
                width: 100%;
                align-items: stretch;
            }
            input[type="range"],
            input[type="number"],
            input[type="color"],
            select,
            textarea { /* Added textarea */
                width: 100%;
            }
            .button-group {
                flex-direction: column;
                gap: 10px;
            }
            button {
                width: 100%;
            }
            .checkbox-group {
                justify-content: center;
                width: 100%;
            }
        }
    </style>
</head>
<body>

    <div class="controls-container">
        <div class="control-group">
            <label for="bpmSlider">BPM (Beats per Minute):</label>
            <input type="range" id="bpmSlider" min="0" max="240" value="60" step="1">
            <span id="currentBPM" class="current-value">60</span>
        </div>

        <div class="control-group">
            <label for="bpmSoundSlider">BPM Sound (0-4):</label>
            <input type="range" id="bpmSoundSlider" min="0" max="4" value="1" step="1">
            <span id="currentBPMSound" class="current-value">1</span>
        </div>

        <div class="control-group">
            <label for="sizeSlider">Size:</label>
            <input type="range" id="sizeSlider" min="10" max="200" value="30" step="5"> <!-- Max changed to 200 -->
            <span id="currentSize" class="current-value">30 px</span>
        </div>

        <div class="control-group">
            <label for="durationInput">Duration (seconds):</label>
            <input type="number" id="durationInput" min="5" max="300" value="30">
            <span id="currentDuration" class="current-value">30 seconds</span>
        </div>

        <div class="control-group">
            <label for="shapeColorPicker">Shape Color:</label>
            <input type="color" id="shapeColorPicker" value="#007bff">
            <span id="currentShapeColor" class="current-value">#007bff</span>
        </div>

        <div class="control-group">
            <label for="backgroundColorPicker">Background Color:</label>
            <input type="color" id="backgroundColorPicker" value="#FFFFFF">
            <span id="currentBackgroundColor" class="current-value">#FFFFFF</span>
        </div>

        <div class="control-group">
            <label for="directionSelect">Direction:</label>
            <select id="directionSelect">
                <option value="horizontal">Horizontal</option>
                <option value="vertical">Vertical</option>
                <option value="diagonal">Diagonal</option>
                <option value="random">Random</option>
            </select>
        </div>

        <div class="control-group">
            <label for="shapeSelect">Shape:</label>
            <select id="shapeSelect">
                <option value="dot">Dot</option>
                <option value="square">Square</option>
                <option value="diamond">Diamond</option>
            </select>
        </div>

        <div class="control-group">
            <label for="textInput">Text:</label>
            <textarea id="textInput" placeholder="Enter text here"></textarea>
        </div>

        <div class="control-group">
            <label for="textColorPicker">Text Color:</label>
            <input type="color" id="textColorPicker" value="#FFFFFF">
            <span id="currentTextColor" class="current-value">#FFFFFF</span>
        </div>

        <div class="button-group">
            <button id="startButton">Start</button>
            <button id="stopButton">Stop</button>
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="moveShapeCheckbox" checked>
            <label for="moveShapeCheckbox">Move Shape</label>
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="fullscreenCheckbox" checked>
            <label for="fullscreenCheckbox">Run in Fullscreen</label>
        </div>
    </div>

    <canvas id="gazeCanvas" width="800" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gazeCanvas');
        const ctx = canvas.getContext('2d');

        const bpmSlider = document.getElementById('bpmSlider');
        const currentBPMSpan = document.getElementById('currentBPM');
        const bpmSoundSlider = document.getElementById('bpmSoundSlider');
        const currentBPMSoundSpan = document.getElementById('currentBPMSound');
        const sizeSlider = document.getElementById('sizeSlider');
        const currentSizeSpan = document.getElementById('currentSize');
        const durationInput = document.getElementById('durationInput');
        const currentDurationSpan = document.getElementById('currentDuration');
        const shapeColorPicker = document.getElementById('shapeColorPicker');
        const currentShapeColorSpan = document.getElementById('currentShapeColor');
        const backgroundColorPicker = document.getElementById('backgroundColorPicker');
        const currentBackgroundColorSpan = document.getElementById('currentBackgroundColor');
        const directionSelect = document.getElementById('directionSelect');
        const shapeSelect = document.getElementById('shapeSelect');
        const textInput = document.getElementById('textInput');
        const textColorPicker = document.getElementById('textColorPicker');
        const currentTextColorSpan = document.getElementById('currentTextColor');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const fullscreenCheckbox = document.getElementById('fullscreenCheckbox');
        const moveShapeCheckbox = document.getElementById('moveShapeCheckbox');

        let animationFrameId;
        let shape = {
            // Default position now centered
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: parseInt(sizeSlider.value),
            color: shapeColorPicker.value,
            dx: 0,
            dy: 0
        };
        let startTime = 0;
        let durationMs = parseInt(durationInput.value) * 1000;
        let currentDirection = directionSelect.value;
        let currentShape = shapeSelect.value;
        let currentBackgroundColor = backgroundColorPicker.value;
        let currentTextColor = textColorPicker.value;

        // Audio context for metronome sound
        let audioContext;
        let lastBeatTime = 0;
        let beatIntervalMs = 0;
        let subdivisions = 1; // 0: no sound, 1: 1 tick/beat, 2: 2 ticks/beat, etc.

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume audio context to allow sound playback. Required due to browser autoplay policies.
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(e => console.error("Failed to resume AudioContext:", e));
            }
        }

        /**
         * Plays a short "tick" sound.
         * @param {number} frequency The base frequency of the sound. Higher for main beat.
         * @param {number} duration The duration of the sound in seconds.
         * @param {number} volume The volume of the sound (0.0 to 1.0).
         */
        function playClick(frequency = 800, duration = 0.02, volume = 0.5) {
            if (!audioContext || subdivisions === 0) return; // No sound if subdivisions is 0

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = 'sine'; // Simple sine wave for a clean tick
            oscillator.frequency.value = frequency;

            // Create a quick attack and decay for a "tick" sound
            gainNode.gain.setValueAtTime(0, audioContext.currentTime); // Start from 0 volume
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.001); // Quick attack
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration); // Quick decay to almost silent

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }


        // Function to draw the shape and text
        function drawShape() {
            ctx.fillStyle = currentBackgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = shape.color;
            ctx.beginPath();

            const halfSize = shape.size;

            switch (currentShape) {
                case 'dot':
                    ctx.arc(shape.x, shape.y, halfSize, 0, Math.PI * 2);
                    break;
                case 'square':
                    ctx.rect(shape.x - halfSize, shape.y - halfSize, halfSize * 2, halfSize * 2);
                    break;
                case 'diamond':
                    ctx.moveTo(shape.x, shape.y - halfSize);
                    ctx.lineTo(shape.x + halfSize, shape.y);
                    ctx.lineTo(shape.x, shape.y + halfSize);
                    ctx.lineTo(shape.x - halfSize, shape.y);
                    ctx.closePath();
                    break;
            }
            ctx.fill();

            // Draw text if available
            const textToDisplay = textInput.value.trim();
            if (textToDisplay) {
                ctx.fillStyle = currentTextColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Determine max font size to fit within the shape
                let fontSize = shape.size * 1.5;
                ctx.font = `${fontSize}px sans-serif`;
                let textWidth = ctx.measureText(textToDisplay).width;
                let textHeight = fontSize;

                // Adjust font size until text fits within the shape (considering padding)
                const paddingFactor = 0.8;
                const maxDim = Math.min(halfSize * 2 * paddingFactor, halfSize * 2 * paddingFactor);

                while ((textWidth > maxDim || textHeight > maxDim) && fontSize > 5) {
                    fontSize -= 1;
                    ctx.font = `${fontSize}px sans-serif`;
                    textWidth = ctx.measureText(textToDisplay).width;
                    textHeight = fontSize;
                }

                ctx.fillText(textToDisplay, shape.x, shape.y);
            }
        }

        function calculateSpeeds() {
            const bpm = parseInt(bpmSlider.value);
            if (bpm === 0) {
                shape.dx = 0;
                shape.dy = 0;
                beatIntervalMs = 0;
                return;
            }

            beatIntervalMs = (60 / bpm) * 1000; // Milliseconds per beat

            // Calculate movement per frame for a round trip within one beat
            // A round trip covers 2 * (canvas edge - shape size) pixels in one direction
            // So, for horizontal: (canvas.width - 2 * shape.size) pixels in one direction, then back.
            // Total distance for a horizontal beat: 2 * (canvas.width - 2 * shape.size)
            // Total distance for a vertical beat: 2 * (canvas.height - 2 * shape.size)

            // Speed in pixels per millisecond
            let speedPxPerMsX = (canvas.width - 2 * shape.size) / beatIntervalMs;
            let speedPxPerMsY = (canvas.height - 2 * shape.size) / beatIntervalMs;

            // Convert to speed per animation frame (assuming 60 FPS, 1 frame ~ 16.67ms)
            // This is a simplification; for precise timing, delta time should be used in animate()
            const frameDuration = 1000 / 60; // Approx ms per frame at 60 FPS

            shape.dx = speedPxPerMsX * frameDuration;
            shape.dy = speedPxPerMsY * frameDuration;
        }

        // Function to generate a random speed value (positive or negative)
        function getRandomSpeed(baseSpeed) {
            const sign = Math.random() < 0.5 ? 1 : -1;
            return baseSpeed * sign;
        }

        // Animation loop
        function animate(currentTime) {
            if (!startTime) startTime = currentTime;
            const elapsedTime = currentTime - startTime;

            if (elapsedTime >= durationMs) {
                stopAnimation();
                return;
            }

            // Metronome sound logic
            if (beatIntervalMs > 0 && subdivisions > 0) {
                const timeIntoBeat = (elapsedTime % beatIntervalMs);
                const beatUnit = beatIntervalMs / subdivisions;

                for (let i = 0; i < subdivisions; i++) {
                    const threshold = beatUnit * i;
                    // Check if current time has crossed the threshold since last frame
                    // and that it's not the very beginning of the animation (startTime == 0 case)
                    // The condition `lastBeatTime === 0` handles the very first beat when startTime is set.
                    // The `(lastBeatTime % beatIntervalMs) < threshold` ensures the sound only plays once
                    // when the threshold is crossed, not continuously while `timeIntoBeat >= threshold`.
                    if (timeIntoBeat >= threshold && (lastBeatTime === 0 || (lastBeatTime % beatIntervalMs) < threshold)) {
                        // Play a slightly higher frequency for the first beat (downbeat)
                        playClick(i === 0 ? 900 : 700);
                    }
                }
            }
            lastBeatTime = currentTime;


            if (moveShapeCheckbox.checked) {
                switch (currentDirection) {
                    case 'horizontal':
                        shape.x += shape.dx;
                        break;
                    case 'vertical':
                        shape.y += shape.dy;
                        break;
                    case 'diagonal':
                    case 'random':
                        shape.x += shape.dx;
                        shape.y += shape.dy;
                        break;
                }

                const minX = shape.size;
                const maxX = canvas.width - shape.size;
                const minY = shape.size;
                const maxY = canvas.height - shape.size;

                // Bounce off horizontal walls
                if (shape.x > maxX || shape.x < minX) {
                    shape.dx *= -1;
                    // Adjust position to prevent sticking
                    if (shape.x > maxX) shape.x = maxX;
                    else if (shape.x < minX) shape.x = minX;

                    if (currentDirection === 'random') {
                         shape.dy = getRandomSpeed(Math.abs(shape.dy || shape.dx)); // Use current speed magnitude
                    }
                }

                // Bounce off vertical walls
                if (shape.y > maxY || shape.y < minY) {
                    shape.dy *= -1;
                    // Adjust position to prevent sticking
                    if (shape.y > maxY) shape.y = maxY;
                    else if (shape.y < minY) shape.y = minY;

                    if (currentDirection === 'random') {
                        shape.dx = getRandomSpeed(Math.abs(shape.dx || shape.dy)); // Use current speed magnitude
                    }
                }
            } else {
                // If not moving, keep it centered
                shape.x = canvas.width / 2;
                shape.y = canvas.height / 2;
                shape.dx = 0;
                shape.dy = 0;
            }

            drawShape();

            animationFrameId = requestAnimationFrame(animate);
        }

        // Start animation
        function startAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            startTime = 0;
            lastBeatTime = 0; // Reset beat tracking for new animation start
            initAudio(); // Initialize and resume audio context

            calculateSpeeds();

            if (moveShapeCheckbox.checked) {
                switch (currentDirection) {
                    case 'horizontal':
                        shape.dx = Math.abs(shape.dx); // Ensure initial movement is to the right
                        shape.dy = 0;
                        shape.x = shape.size; // Start from left edge for full trip
                        shape.y = canvas.height / 2; // Keep centered vertically
                        break;
                    case 'vertical':
                        shape.dx = 0;
                        shape.dy = Math.abs(shape.dy); // Ensure initial movement is downwards
                        shape.x = canvas.width / 2; // Keep centered horizontally
                        shape.y = shape.size; // Start from top edge for full trip
                        break;
                    case 'diagonal':
                        shape.dx = Math.abs(shape.dx); // Move right
                        shape.dy = -Math.abs(shape.dy); // Move up
                        shape.x = shape.size; // Start from bottom-left corner for full trip
                        shape.y = canvas.height - shape.size;
                        break;
                    case 'random':
                        shape.dx = getRandomSpeed(Math.abs(shape.dx));
                        shape.dy = getRandomSpeed(Math.abs(shape.dy));
                        shape.x = canvas.width / 2;
                        shape.y = canvas.height / 2;
                        break;
                }
            } else {
                // If not moving, ensure it's centered and has no velocity
                shape.x = canvas.width / 2;
                shape.y = canvas.height / 2;
                shape.dx = 0;
                shape.dy = 0;
            }


            startButton.disabled = true;
            stopButton.disabled = false;

            // Request fullscreen for the canvas ONLY if checkbox is checked
            if (fullscreenCheckbox.checked) {
                try {
                    if (canvas.requestFullscreen) {
                        canvas.requestFullscreen();
                    } else if (canvas.webkitRequestFullscreen) { /* Safari */
                        canvas.webkitRequestFullscreen();
                    } else if (canvas.msRequestFullscreen) { /* IE11 */
                        canvas.msRequestFullscreen();
                    }
                } catch (error) {
                    console.error("Failed to enter fullscreen:", error);
                    // Continue animation even if fullscreen fails
                }
            }

            animate();
        }

        // Stop animation
        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            startButton.disabled = false;
            stopButton.disabled = true;
            console.log("Animation stopped.");
            lastBeatTime = 0; // Reset beat tracking

            // Exit fullscreen if currently in fullscreen AND the checkbox was checked
            if (fullscreenCheckbox.checked && (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement)) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
        }

        // Event listener for exiting fullscreen (e.g., via Esc key)
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                // If exiting fullscreen, stop the animation
                stopAnimation();
            }
        });
        document.addEventListener('webkitfullscreenchange', () => { // For Safari
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                stopAnimation();
            }
        });
        document.addEventListener('msfullscreenchange', () => { // For IE11
            if (!document.fullscreenElement && !document.msFullscreenElement && !document.webkitFullscreenElement) {
                stopAnimation();
            }
        });


        // Event Listeners for controls
        bpmSlider.addEventListener('input', (event) => {
            const newBPM = parseInt(event.target.value);
            currentBPMSpan.textContent = newBPM;
            calculateSpeeds();
            if (!animationFrameId) {
                if (!moveShapeCheckbox.checked) {
                    shape.x = canvas.width / 2;
                    shape.y = canvas.height / 2;
                }
                drawShape();
            }
        });

        bpmSoundSlider.addEventListener('input', (event) => {
            subdivisions = parseInt(event.target.value);
            currentBPMSoundSpan.textContent = subdivisions;
        });

        sizeSlider.addEventListener('input', (event) => {
            shape.size = parseInt(event.target.value);
            currentSizeSpan.textContent = `${shape.size} px`;
            calculateSpeeds();
            if (!animationFrameId) {
                drawShape();
            }
        });

        durationInput.addEventListener('input', (event) => {
            durationMs = parseInt(event.target.value) * 1000;
            currentDurationSpan.textContent = `${event.target.value} seconds`;
        });

        shapeColorPicker.addEventListener('input', (event) => {
            shape.color = event.target.value;
            currentShapeColorSpan.textContent = event.target.value;
            if (!animationFrameId) {
                drawShape();
            }
        });

        backgroundColorPicker.addEventListener('input', (event) => {
            currentBackgroundColor = event.target.value;
            currentBackgroundColorSpan.textContent = event.target.value;
            drawShape();
        });

        directionSelect.addEventListener('change', (event) => {
            currentDirection = event.target.value;
            stopAnimation(); // Stop to reset position on direction change
            drawShape();
        });

        shapeSelect.addEventListener('change', (event) => {
            currentShape = event.target.value;
            stopAnimation(); // Stop to reset position on shape change
            drawShape();
        });

        textInput.addEventListener('input', () => {
            if (!animationFrameId) {
                drawShape();
            }
        });

        textColorPicker.addEventListener('input', (event) => {
            currentTextColor = event.target.value;
            currentTextColorSpan.textContent = event.target.value;
            if (!animationFrameId) {
                drawShape();
            }
        });

        moveShapeCheckbox.addEventListener('change', () => {
            if (!moveShapeCheckbox.checked) {
                shape.x = canvas.width / 2;
                shape.y = canvas.height / 2;
                shape.dx = 0;
                shape.dy = 0;
                drawShape();
            } else {
                calculateSpeeds();
                if (animationFrameId) {
                    startAnimation();
                }
            }
        });


        startButton.addEventListener('click', startAnimation);
        stopButton.addEventListener('click', stopAnimation);

        // Initial draw when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            stopButton.disabled = true;
            currentBPMSpan.textContent = bpmSlider.value;
            currentBPMSoundSpan.textContent = bpmSoundSlider.value;
            currentSizeSpan.textContent = `${sizeSlider.value} px`;
            currentDurationSpan.textContent = `${durationInput.value} seconds`;
            currentShapeColorSpan.textContent = shapeColorPicker.value;
            currentBackgroundColorSpan.textContent = backgroundColorPicker.value;
            currentTextColorSpan.textContent = textColorPicker.value;
            calculateSpeeds();
            resizeCanvas();
        });

        // Handle canvas resizing for responsiveness
        function resizeCanvas() {
            if (document.fullscreenElement === canvas || document.webkitFullscreenElement === canvas || document.msFullscreenElement === canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                const containerWidth = canvas.parentElement.clientWidth;
                canvas.width = Math.min(containerWidth, 800);
                canvas.height = canvas.width * 0.75;
            }

            // Always center if not moving, otherwise adjust for boundaries
            if (!animationFrameId || !moveShapeCheckbox.checked) {
                shape.x = canvas.width / 2;
                shape.y = canvas.height / 2;
            } else {
                shape.x = Math.max(shape.size, Math.min(shape.x, canvas.width - shape.size));
                shape.y = Math.max(shape.size, Math.min(shape.y, canvas.height - shape.size));
            }
            calculateSpeeds();
            drawShape();
        }

        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>
