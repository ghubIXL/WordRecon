<html>
  <head>
    <title>Web Speech Synthesis Demo</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #f4f4f4; /* Light background for overall page */
        color: #333;
        line-height: 1.6;
        margin: 0;
        padding: 20px; /* Add some padding around the content */
        box-sizing: border-box;
      }
      h1 {
        color: #0056b3;
        margin: 20px auto; /* Center heading */
        text-align: center;
        font-size: 2.5em;
        border-bottom: 2px solid #0056b3;
        padding-bottom: 10px;
        max-width: 800px; /* Limit width of main heading */
      }
      h2, h3, h4 {
        color: #0056b3;
        margin-top: 25px;
        margin-bottom: 15px;
        font-weight: 600;
      }
      form {
        max-width: 480px;
        margin: 0 auto;
        padding: 20px;
        background-color: #fff;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        margin-bottom: 30px; /* Space below the main speech form */
      }
      button, select {
        background-color: #fff;
        border: none;
        border-radius: 8px; /* Slightly more rounded */
        height: 2.5rem; /* Increased height for better touch target */
        padding: 0 15px; /* Added padding */
        font-size: 1em; /* Standard font size */
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      }
      select {
       -webkit-appearance: none;
       -moz-appearance: none;
       appearance: none;
       padding-right: 30px; /* Space for custom arrow if needed */
     }

     /* Some firefox range styling */
     input[type=range] {
      -moz-appearance: none;
     }
     input[type=range]::-moz-range-thumb {
      background-color: #007bff; /* Changed to match button blue */
      height: 1rem;
      width: .5rem;
      border-color: #007bff;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.5);
     }
     input[type=range]::-moz-range-track {
      background-color: #ddd; /* Lighter track */
     }

      .speecharg {
        height: 2.5rem; /* Match button height */
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px; /* Space between controls */
      }
      .speecharg label {
        display: inline-block;
        width: 25%; /* Adjusted width */
        font-weight: 500;
      }
      .speecharg input[type="range"], .speecharg select {
        display: inline-block;
        width: calc(75% - 3rem); /* Adjusted width */
        margin: 0;
      }
      .speecharg button {
        width: 2.5rem; /* Square reset buttons */
        height: 2.5rem;
        margin: 0 0 0 1rem; /* Reduced margin */
        padding: 0;
        background-color: #6c757d; /* Grey for reset */
        color: white;
      }
      .speecharg button:hover {
        background-color: #5a6268;
      }

      .bottom {
        margin-top: 20px; /* More space above action buttons */
        display: flex;
        justify-content: space-between;
        gap: 15px; /* Space between button groups */
      }
      .bottom > div {
        flex: 1; /* Allow widebutton to take available space */
      }
      .bottom button.small {
        height: 3.5rem; /* Larger touch target */
        width: 3.5rem;
        padding: 0;
        border-radius: 50%; /* Circular buttons */
        background-color: #007bff; /* Blue for play/pause */
        color: white;
      }
      .bottom button.small:hover {
        background-color: #0056b3;
      }
      .bottom button.small img {
        width: 60%; /* Make icons smaller */
        height: auto;
        display: block;
        margin: auto;
      }

      .widebutton {
        width: auto; /* Let flexbox handle width */
        display: flex;
        flex-direction: column;
        gap: 10px; /* Space between stacked buttons */
      }
      .widebutton > button {
        display: block;
        width: 100%;
        background-color: #28a745; /* Green for Speak It */
        color: white;
      }
      .widebutton > button#preachit {
        background-color: #dc3545; /* Red for Interrupt */
      }
      .widebutton > button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      }

      #textarea {
         width: 100%;
         height: 8rem;
         display: block;
         margin-bottom: 1rem;
         border-radius: 5px;
         position: relative;
         background-color: #fff;
         transition: background-color 100ms ease;
         -webkit-transition: background-color 100ms ease;
         box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
       }

       .speaking #textarea {
        background-color: #e6ffe6; /* Light green when speaking */
       }

      #textarea > * {
        position: absolute;
        display: block;
        border: none;
        resize: none;
        top: 0;
        left: 0;
        width: calc(100% - 1rem);
        height: calc(100% - 1rem);
        margin: .5rem;
        padding: 0;
        white-space: pre-wrap;
        line-height: 1.1rem;
        background-color: transparent;
        font-size: 14px; /* Slightly larger font */
        font-family: 'Inter', sans-serif; /* Use Inter font */
        color: #333;
      }

      #textbeingspoken {
        color: #555; /* Darker grey for spoken text */
        visibility: hidden;
        opacity: 0;
        overflow: auto;
        transition: all 100ms ease;
        -webkit-transition: all 100ms ease;
       }

       .speaking #textbeingspoken {
        visibility: visible;
        opacity: 1;
       }

      a#gh {
        color: #333;
        text-align: right;
        display: block;
        font-style: italic;
        margin-top: 20px;
      }

      #marker {
        position: absolute;
        visibility: hidden;
        border: 2px solid #ffc107; /* Orange marker */
        border-radius: 3px;
        background-color: rgba(255, 193, 7, 0.2); /* Light orange background */
      }

      #marker.moved {
        visibility: visible;
      }
      #marker.animate {
        transition: all 50ms ease;
        -webkit-transition: all 50ms ease;
      }

      /* Minimal Pair Specific Styles */
      .category-container, .subcategory-container, .contrast-group {
          margin: 0 auto 30px auto; /* Center and add margin */
          padding: 20px;
          border: 1px solid #ddd;
          border-radius: 10px;
          background-color: #fff;
          box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
          max-width: 800px; /* Max width for categories */
      }
      .subcategory-container {
          margin-top: 20px;
          background-color: #f9f9f9;
          border-color: #eee;
          box-shadow: none;
      }
      .contrast-group {
          margin-top: 15px;
          padding: 15px;
          border: 1px dashed #ccc;
          background-color: #fafafa;
          border-radius: 8px;
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 15px;
      }
      .pair-section {
          display: flex;
          flex-direction: column;
          gap: 8px;
          margin-bottom: 5px;
          padding-bottom: 5px;
          border-bottom: 1px dotted #eee;
          width: 100%;
      }
      .contrast-group .pair-section:last-child {
          border-bottom: none;
          margin-bottom: 0;
          padding-bottom: 0;
      }
      .pair-label {
          font-weight: bold;
          font-size: 1.1em;
          color: #555;
      }
      .button-pair {
          display: flex;
          align-items: center;
          flex-wrap: wrap;
          gap: 10px;
      }
      .button-pair button {
          padding: 10px 15px; /* Slightly smaller padding for these buttons */
          font-size: 0.95em;
          border-radius: 6px;
          height: auto; /* Auto height for text content */
      }
      button.listen-pair {
          background-color: #007bff;
      }
      button.listen-pair:hover {
          background-color: #0056b3;
      }
      button.test-pair {
          background-color: #ffc107;
          color: #333;
      }
      button.test-pair:hover {
          background-color: #e0a800;
      }
      #pauseValue {
          min-width: 70px;
          text-align: center;
          font-weight: bold;
          color: #0056b3;
      }
      .controls {
          position: sticky;
          top: 0;
          width: 100%;
          background-color: #f4f4f4;
          padding: 15px 20px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          z-index: 1000;
          display: flex;
          flex-wrap: wrap;
          align-items: center;
          gap: 15px;
          box-sizing: border-box;
          border-bottom: 1px solid #ddd;
      }
      .controls label {
          white-space: nowrap;
          font-weight: 500;
          color: #555;
      }
      .controls .control-group {
          display: flex;
          align-items: center;
          gap: 8px;
          flex-wrap: wrap;
      }
      #loadingStatus {
          font-weight: bold;
          color: #dc3545;
          margin-top: 10px;
      }
      #mainContentWrapper {
          margin-top: 0; /* Will be set by JS */
      }

      /* Custom Modal Styles */
      .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 2000;
      }

      .modal-content {
          background-color: #fff;
          padding: 30px;
          border-radius: 10px;
          box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
          text-align: center;
          max-width: 90%;
          width: 450px;
          animation: fadeIn 0.3s ease-out;
      }

      .modal-content p {
          font-size: 1.4em;
          margin-bottom: 25px;
          color: #333;
          font-weight: 600;
      }

      .modal-buttons {
          display: flex;
          justify-content: center;
          gap: 20px;
          margin-bottom: 20px;
      }

      .modal-buttons button {
          flex: 1;
          max-width: 180px;
          padding: 15px 25px;
          font-size: 1.2em;
          background-color: #007bff;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          transition: background-color 0.2s ease, transform 0.1s ease;
          box-shadow: 0 3px 6px rgba(0,0,0,0.1);
      }

      .modal-buttons button:hover {
          background-color: #0056b3;
          transform: translateY(-1px);
      }

      .feedback-message {
          margin-top: 20px;
          font-weight: bold;
          font-size: 1.5em;
          animation: slideIn 0.5s ease-out;
      }

      .feedback-message.correct {
          color: #28a745;
      }

      .feedback-message.wrong {
          color: #dc3545;
      }

      @keyframes fadeIn {
          from { opacity: 0; transform: translateY(-20px); }
          to { opacity: 1; transform: translateY(0); }
      }

      @keyframes slideIn {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
      }
      /* Responsive adjustments */
      @media (max-width: 768px) {
          h1 {
              font-size: 2em;
              margin: 15px;
          }
          .category-container, .subcategory-container, .contrast-group {
              margin: 0 10px 20px 10px;
              padding: 15px;
          }
          .controls {
              padding: 10px;
              gap: 10px;
          }
          .controls .control-group {
              flex-direction: column;
              align-items: flex-start;
              width: 100%;
          }
          .controls select, .controls input[type="text"], .controls input[type="range"] {
              width: 100%;
              margin-right: 0;
          }
          .button-pair {
              flex-direction: column;
              width: 100%;
          }
          .button-pair button {
              width: 100%;
              margin: 5px 0;
          }
          .modal-content {
              padding: 20px;
          }
          .modal-buttons {
              flex-direction: column;
              gap: 10px;
          }
          .modal-buttons button {
              max-width: 100%;
          }
      }
    </style>
  </head>
  <body class="loading">
    <!-- Removed main H1 -->

    <!-- Removed original form with textarea and controls -->

    <!-- Removed marker div -->

    <!-- Minimal Pairs Section -->
    <div class="controls" id="stickyControls">
        <div class="control-group">
            <label for="voiceSelect">Select Voice:</label>
            <select id="voiceSelect"></select>
        </div>

        <div class="control-group">
            <label for="pauseSlider">Pause:</label>
            <input type="range" id="pauseSlider" min="100" max="3000" value="1000" step="100">
            <span id="pauseValue">1.0 sec</span>
        </div>

        <div class="control-group">
            <label for="textBox1">Word 1:</label>
            <input type="text" id="textBox1" value="Red">
            <label for="textBox2">Word 2:</label>
            <input type="text" id="textBox2" value="Read">
        </div>

        <div class="control-group">
            <button id="speakFirstWordButton" class="play-word">First</button>
            <button id="speakSecondWordButton" class="play-word">Second</button>
            <button id="speakCustomPairButton" class="listen-pair">Listen Pair</button>
            <button id="testCustomPairButton" class="test-pair">Test</button>
        </div>
    </div>

    <div id="mainContentWrapper">
        <div id="wordButtonsContainer">
            <!-- Word categories and buttons will be dynamically loaded here -->
        </div>
    </div>

    <!-- Custom Modal for Test Functionality -->
    <div id="testModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <p id="modalQuestion">Which word did you hear?</p>
            <div class="modal-buttons">
                <button id="modalOption1"></button>
                <button id="modalOption2"></button>
            </div>
            <p id="modalFeedback" class="feedback-message"></p>
        </div>
    </div>

    <script type="text/javascript">
        // Removed texttospeak, textbeingspoken, marker, range, speechtext, firstBoundary as their HTML elements are removed.
        // Their associated functions (speak, stop, playpause, handleSpeechEvent) are kept as per instruction,
        // but will effectively be unused or non-functional without their corresponding DOM elements.

        var voices = [];
        // Renamed for clarity to avoid conflict with minimal pair's voiceSelect
        var mainVoiceSelect = document.querySelector('#voice'); // This element is now removed from HTML

        function populateVoiceList() {
          voices = window.speechSynthesis.getVoices();
          // mainVoiceSelect.innerHTML = ''; // This line will now cause an error as mainVoiceSelect is null/undefined
          var minimalPairVoiceSelect = document.getElementById('voiceSelect'); // Get minimal pair voice select
          minimalPairVoiceSelect.innerHTML = ''; // Clear minimal pair voice select

          // Sort voices for consistent order
          voices.sort((a, b) => {
              const aname = a.name.toUpperCase();
              const bname = b.name.toUpperCase();
              if (aname < bname) return -1;
              if (aname > bname) return +1;
              return 0;
          });

          if (voices.length === 0) {
              console.warn("No voices available. This might be due to browser limitations or voices not being loaded yet.");
              // mainVoiceSelect.innerHTML = '<option value="">No Voices Available</option>'; // This will also error
              minimalPairVoiceSelect.innerHTML = '<option value="">No Voices Available</option>';
              return;
          }

          let defaultVoiceFound = false;

          for (var i = 0; i < voices.length; i++) {
            // var optionMain = document.createElement('option'); // This is no longer needed
            // optionMain.innerHTML = voices[i].name + ' (' + voices[i].lang + ')';
            // optionMain.setAttribute('value', voices[i].voiceURI);
            // optionMain.voice = voices[i]; // Store voice object directly

            var optionMinimal = document.createElement('option');
            optionMinimal.textContent = `${voices[i].name} (${voices[i].lang})`;
            optionMinimal.setAttribute('data-index', i); // Store index for minimal pair logic

            if (voices[i].default || (voices[i].lang === 'en-US' && !defaultVoiceFound)) {
              // optionMain.selected = true; // No longer needed
              optionMinimal.selected = true;
              defaultVoiceFound = true;
            }
            // mainVoiceSelect.appendChild(optionMain); // No longer needed
            minimalPairVoiceSelect.appendChild(optionMinimal);
          }

          // Fallback if no default or en-US voice was found
          if (!defaultVoiceFound && voices.length > 0) {
              // mainVoiceSelect.options[0].selected = true; // No longer needed
              minimalPairVoiceSelect.options[0].selected = true;
          }
          console.log("Voice list populated. Total voices:", voices.length);
        }

        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined)
          speechSynthesis.onvoiceschanged = populateVoiceList;

        // Ensure voice selection in minimal pair section updates main voice selection
        // This listener will now only update itself if mainVoiceSelect is removed
        document.getElementById('voiceSelect').addEventListener('change', function() {
            const selectedIndex = this.selectedIndex;
            // mainVoiceSelect.selectedIndex = selectedIndex; // This line will now cause an error
        });

        // Ensure main voice selection updates minimal pair section
        // This listener will now cause an error as mainVoiceSelect is null/undefined
        // mainVoiceSelect.addEventListener('change', function() {
        //     const selectedIndex = this.selectedIndex;
        //     document.getElementById('voiceSelect').selectedIndex = selectedIndex;
        // });

        // These functions are kept as per instruction, but their elements are removed.
        function resetPitch() {
            // document.getElementById('pitch').value = 0.5; // This will error
        }
        function resetRate() {
            // document.getElementById('rate').value = 0; // This will error
        }
        function resetVolume() {
            // document.getElementById('volume').value = 1; // This will error
        }
        function resetVoice() {
            // document.getElementById('default-voice').selected = true; // This will error
        }
        function stop() {
          speechSynthesis.cancel();
        }

        function playpause() {
          if (speechSynthesis.paused)
            speechSynthesis.resume();
          else
            speechSynthesis.pause();
        }

        function speak() {
          // speechtext = texttospeak.value; // This will error
          firstBoundary = true;
          // textbeingspoken.textContent = speechtext; // This will error

          utterance = new SpeechSynthesisUtterance(
            // document.getElementById('texttospeak').value); // This will error
            "Placeholder text for removed main text area." // Use placeholder for now
            );
          // Use the voice selected in the main dropdown (now removed)
          // utterance.voice = voices[mainVoiceSelect.selectedIndex]; // This will error
          utterance.voice = voices[document.getElementById('voiceSelect').selectedIndex]; // Use minimal pair voice select for main speak function
          // utterance.volume = document.getElementById('volume').value; // This will error
          // utterance.pitch = document.getElementById('pitch').value; // This will error
          // var rate = document.getElementById('rate').value; // This will error
          // utterance.rate = Math.pow(Math.abs(rate) + 1, rate < 0 ? -1 : 1); // This will error
          utterance.volume = 1; // Default
          utterance.pitch = 1; // Default
          utterance.rate = 1; // Default

          utterance.addEventListener('start', function () {
            // marker.classList.remove('animate'); // This will error
            document.body.classList.add('speaking');
          });
          utterance.addEventListener('start', handleSpeechEvent);
          utterance.addEventListener('end', handleSpeechEvent);
          utterance.addEventListener('error', handleSpeechEvent);
          utterance.addEventListener('boundary', handleSpeechEvent);
          utterance.addEventListener('pause', handleSpeechEvent);
          utterance.addEventListener('resume', handleSpeechEvent);

          if (utterance.voice) { // Only speak if a valid voice is selected
              speechSynthesis.speak(utterance);
          } else {
              console.warn("No valid voice selected for main text-to-speech.");
              document.body.classList.remove('speaking');
              // marker.classList.remove('moved'); // This will error
          }
        }

        function handleSpeechEvent(e) {
          console.log('Speech Event:', e);

          switch (e.type) {
            case 'start':
              // marker.classList.remove('animate'); // This will error
              document.body.classList.add('speaking');
              break;
            case 'end':
            case 'endEvent':
            case 'error':
              document.body.classList.remove('speaking');
              // marker.classList.remove('moved'); // This will error
              break;
            case 'boundary':
            {
              // The following lines depend on textbeingspoken and marker, which are removed.
              // This entire block will cause errors or be non-functional.
              // if (e.name != 'word')
              //   break;
              // var substr = speechtext.slice(e.charIndex);
              // var rex = /\S+/g;
              // var res = rex.exec(substr);
              // if (!res) return;
              // var startOffset = res.index + e.charIndex;
              // var endOffset = rex.lastIndex + e.charIndex;
              // range.setStart(textbeingspoken.firstChild, startOffset);
              // range.setEnd(textbeingspoken.firstChild, endOffset);
              // var rect = range.getBoundingClientRect();
              // var delta = 0;
              // // do I need to scroll?
              // var parentRect = textbeingspoken.getBoundingClientRect();
              // if (rect.bottom > parentRect.bottom) {
              //   delta = rect.bottom - parentRect.bottom;
              // }
              // if (rect.top < parentRect.top) {
              //   delta = rect.top - parentRect.top;
              // }

              // textbeingspoken.scrollTop += delta;
              // texttospeak.scrollTop = textbeingspoken.scrollTop;

              // marker.style.top = rect.top - delta - 1;
              // marker.style.left = rect.left - 1;
              // marker.style.width = rect.width + 1;
              // marker.style.height = rect.height + 1;
              // marker.classList.add('moved');
              // if (firstBoundary) {
              //   firstBoundary = false;
              //   marker.classList.add('animate');
              // }
              break;
            }
            default:
              break;
          }
        }

        // --- Minimal Pairs Specific Logic (Integrated) ---

        // Embedded JSON Data for Minimal Pairs
        const embeddedWordData = [
            {
                "category": "Initial Consonant",
                "subcategories": [
                    {
                        "name": "Differing by Place (where the sound is made)",
                        "contrasts": [
                            {
                                "description": "/p/ vs. /t/",
                                "pairs": [
                                    ["Pan", "Tan"], ["Pin", "Tin"], ["Pot", "Tot"], ["Pick", "Tick"], ["Pale", "Tale"], ["Pat", "Tat"], ["Pill", "Till"], ["Pug", "Tug"], ["Pest", "Test"], ["Pore", "Tore"], ["Pea", "Tea"], ["Pace", "Taste"], ["Pipe", "Type"], ["Pool", "Tool"], ["Pail", "Tail"]
                                ]
                            },
                            {
                                "description": "/b/ vs. /d/",
                                "pairs": [
                                    ["Bat", "Dat"], ["Big", "Dig"], ["Bell", "Dell"], ["Buy", "Dye"], ["Back", "Dack"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /k/",
                                "pairs": [
                                    ["Pat", "Cat"], ["Pool", "Cool"], ["Pear", "Care"], ["Page", "Cage"]
                                ]
                            },
                            {
                                "description": "/m/ vs. /n/",
                                "pairs": [
                                    ["Mat", "Nat"], ["Me", "Knee"], ["Might", "Night"], ["Met", "Net"]
                                ]
                            },
                            {
                                "description": "/f/ vs. /s/",
                                "pairs": [
                                    ["Fin", "Sin"], ["Fan", "San"], ["Fast", "Sass"], ["Fox", "Socks"]
                                ]
                            },
                            {
                                "description": "/z/ vs. /dʒ/",
                                "pairs": [
                                    ["zest", "jest"], ["zeal", "jail"]
                                ]
                            },                           
                            {
                                "description": "/ʃ/ vs. /s/",
                                "pairs": [
                                    ["Sheep", "Seep"], ["Shun", "Sun"], ["Shame", "Same"], ["Shin", "Sin"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Voicing (vocal cords vibrating or not)",
                        "contrasts": [
                            {
                                "description": "/p/ vs. /b/",
                                "pairs": [
                                    ["Pat", "Bat"], ["Pig", "Big"], ["Pin", "Bin"], ["Pie", "Buy"], ["Pit", "Bit"]
                                ]
                            },
                            {
                                "description": "/t/ vs. /d/",
                                "pairs": [
                                    ["To", "Do"], ["Tip", "Dip"], ["Ten", "Den"], ["Tie", "Die"]
                                ]
                            },
                            {
                                "description": "/k/ vs. /g/",
                                "pairs": [
                                    ["Cat", "Gat"], ["Cut", "Gut"], ["Kiss", "Guess"], ["Came", "Game"]
                                ]
                            },
                            {
                                "description": "/f/ vs. /v/",
                                "pairs": [
                                    ["Fan", "Van"], ["Fine", "Vine"], ["Fat", "Vat"], ["Few", "View"]
                                ]
                            },
                            {
                                "description": "/s/ vs. /z/",
                                "pairs": [
                                    ["Seal", "Zeal"], ["Sink", "Zink"], ["Sip", "Zip"]
                                ]
                            },
                            {
                                "description": "/θ/ vs. /ð/",
                                "pairs": [
                                    ["Thin", "Then"], ["Thigh", "Thy"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Manner (how the air flows)",
                        "contrasts": [
                            {
                                "description": "/p/ (Stop) vs. /f/ (Fricative)",
                                "pairs": [
                                    ["Pan", "Fan"], ["Pat", "Fat"], ["Pill", "Fill"]
                                ]
                            },
                            {
                                "description": "/d/ (Stop) vs. /n/ (Nasal)",
                                "pairs": [
                                    ["Den", "Nen"], ["Dare", "Nair"]
                                ]
                            },
                            {
                                "description": "/tʃ/ (Affricate) vs. /ʃ/ (Fricative)",
                                "pairs": [
                                    ["Cheer", "Shear"], ["Chip", "Ship"], ["Chop", "Shop"]
                                ]
                            },
                            {
                                "description": "/dʒ/ (Affricate) vs. /z/ (Fricative)",
                                "pairs": [
                                    ["jag", "zag"], ["jeep", "zeep"], ["jest", "zest"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Final Consonant",
                "subcategories": [
                    {
                        "name": "Differing by Voicing",
                        "contrasts": [
                            {
                                "description": "/t/ vs. /d/ (Alveolar Stop)",
                                "pairs": [
                                    ["Beat", "Bead"], ["Hat", "Had"], ["Sit", "Sid"], ["Pat", "Pad"], ["Bet", "Bed"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /b/ (Bilabial Stop)",
                                "pairs": [
                                    ["Cap", "Cab"], ["Rip", "Rib"], ["Tap", "Tab"]
                                ]
                            },
                            {
                                "description": "/k/ vs. /g/ (Velar Stop)",
                                "pairs": [
                                    ["Back", "Bag"], ["Lock", "Log"], ["Pick", "Pig"]
                                ]
                            },
                            {
                                "description": "/s/ vs. /z/ (Alveolar Fricative)",
                                "pairs": [
                                    ["Peace", "Peas"], ["Race", "Raise"], ["Bus", "Buzz"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Place",
                        "contrasts": [
                            {
                                "description": "/m/ vs. /n/ (Nasal)",
                                "pairs": [
                                    ["Swim", "Swin"], ["Team", "Teen"]
                                ]
                            },
                            {
                                "description": "/n/ vs. /ŋ/ (Alveolar vs. Velar Nasal)",
                                "pairs": [
                                    ["Sin", "Sing"], ["Ran", "Rang"], ["Win", "Wing"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Manner",
                        "contrasts": [
                            {
                                "description": "/t/ (Stop) vs. /s/ (Fricative)",
                                "pairs": [
                                    ["Hat", "Hass"], ["Pat", "Pass"]
                                ]
                            },
                            {
                                "description": "/d/ (Stop) vs. /z/ (Fricative)",
                                "pairs": [
                                    ["Aid", "Aze"], ["Bid", "Biz"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Vowels",
                "subcategories": [
                    {
                        "name": "Short vs. Long/Tense Vowels",
                        "contrasts": [
                            {
                                "description": "/ɪ/ (short i) vs. /iː/ (long e)",
                                "pairs": [
                                    ["Bin", "Bean"], ["Fit", "Feet"], ["Lip", "Leap"], ["Sip", "Seep"], ["Dill", "Deal"]
                                ]
                            },
                            {
                                "description": "/æ/ (short a) vs. /ɑː/ (broad a)",
                                "pairs": [
                                    ["Cat", "Cart"], ["Bad", "Bard"]
                                ]
                            },
                            {
                                "description": "/ʊ/ (short u) vs. /uː/ (long oo)",
                                "pairs": [
                                    ["Look", "Luke"], ["Pull", "Pool"], ["Should", "Shooed"]
                                ]
                            },
                            {
                                "description": "/ɛ/ (short e) vs. /eɪ/ (long a)",
                                "pairs": [
                                    ["Met", "Mate"], ["Wet", "Wait"], ["Sell", "Sail"], ["Bed", "Bade"]
                                ]
                            },
                            {
                                "description": "/ʌ/ (short u as in 'cut') vs. /ɔː/ (aw as in 'caught')",
                                "pairs": [
                                    ["Cut", "Caught"], ["Duck", "Dock"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Front vs. Back Vowels",
                        "contrasts": [
                            {
                                "description": "/iː/ (long e) vs. /uː/ (long oo)",
                                "pairs": [
                                    ["Feel", "Fool"], ["Leave", "Looze"]
                                ]
                            },
                            {
                                "description": "/æ/ (short a) vs. /ɑː/ (broad a)",
                                "pairs": [
                                    ["Cab", "Cob"], ["Cat", "Cot"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Monophthongs vs. Diphthongs",
                        "contrasts": [
                            {
                                "description": "/ɑː/ (broad a) vs. /aɪ/ (long i)",
                                "pairs": [
                                    ["Dad", "Died"], ["Cop", "Cope"]
                                ]
                            },
                            {
                                "description": "/ɔː/ (aw) vs. /oʊ/ (long o)",
                                "pairs": [
                                    ["Cot", "Coat"], ["Not", "Note"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Consonant Clusters",
                "subcategories": [
                    {
                        "name": "Initial Clusters",
                        "contrasts": [
                            {
                                "description": "/s/ vs. /st/",
                                "pairs": [
                                    ["Sit", "Stir"], ["Sip", "Stripe"]
                                ]
                            },
                            {
                                "description": "/l/ vs. /sl/",
                                "pairs": [
                                    ["Led", "Sled"], ["Light", "Slight"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /sp/",
                                "pairs": [
                                    ["Pin", "Spin"], ["Peak", "Speak"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Final Clusters",
                        "contrasts": [
                            {
                                "description": "/mp/ vs. /nt/",
                                "pairs": [
                                    ["Camp", "Cant"], ["Dump", "Dunt"]
                                ]
                            },
                            {
                                "description": "/st/ vs. /sk/",
                                "pairs": [
                                    ["Last", "Lask"], ["Test", "Tesk"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Medial Consonant",
                "subcategories": [
                    {
                        "name": "Voicing",
                        "contrasts": [
                            {
                                "description": "/t/ vs. /d/",
                                "pairs": [
                                    ["Meta", "Medal"], ["City", "Cider"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Place",
                        "contrasts": [
                            {
                                "description": "/n/ vs. /m/",
                                "pairs": [
                                    ["Winner", "Whimper"], ["Denim", "Demin"]
                                ]
                            }
                        ]
                    }
                ]
            }
        ];

        // Minimal Pair Specific Elements (re-declared to avoid conflict with main script's var names)
        // Note: texttospeak, textbeingspoken, marker, range, speechtext, firstBoundary are now unused
        // as their corresponding HTML elements have been removed.
        const wordButtonsContainer = document.getElementById('wordButtonsContainer');
        const voiceSelect = document.getElementById('voiceSelect'); // This is the minimal pair voice select

        const textBox1 = document.getElementById('textBox1');
        const textBox2 = document.getElementById('textBox2');
        const speakFirstWordButton = document.getElementById('speakFirstWordButton');
        const speakSecondWordButton = document.getElementById('speakSecondWordButton');
        const speakCustomPairButton = document.getElementById('speakCustomPairButton');
        const testCustomPairButton = document.getElementById('testCustomPairButton');

        const pauseSlider = document.getElementById('pauseSlider');
        const pauseValue = document.getElementById('pauseValue');
        const stickyControls = document.getElementById('stickyControls');
        const mainContentWrapper = document.getElementById('mainContentWrapper');

        // Modal elements
        const testModal = document.getElementById('testModal');
        const modalQuestion = document.getElementById('modalQuestion');
        const modalOption1 = document.getElementById('modalOption1');
        const modalOption2 = document.getElementById('modalOption2');
        const modalFeedback = document.getElementById('modalFeedback');

        let currentPauseDurationMs = parseInt(pauseSlider.value);
        let correctWord = ''; // Variable to store the correct word for the test

        // Flag to manage speech state for minimal pairs
        let isSpeechInProgress = false;

        // Helper function to get the selected voice for minimal pairs
        function getSelectedVoiceForMinimalPairs() {
            const selectedIndex = voiceSelect.selectedIndex;
            return voices[selectedIndex]; // Use the global 'voices' array
        }

        // Helper function to wait for speech to stop (re-using main script's synth.cancel)
        async function waitForSpeechToStopMinimalPairs() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            while (speechSynthesis.speaking) {
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            isSpeechInProgress = false;
        }

        // Speak function for minimal pairs
        async function speakWordMinimalPairs(word) {
            return new Promise(async (resolve) => {
                await waitForSpeechToStopMinimalPairs();

                isSpeechInProgress = true;

                const utterance = new SpeechSynthesisUtterance(word);
                utterance.voice = getSelectedVoiceForMinimalPairs();
                utterance.pitch = 1;
                utterance.rate = 1;

                utterance.onend = () => {
                    isSpeechInProgress = false;
                    resolve();
                };
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror (Minimal Pairs)', event.error, `Word: "${word}"`);
                    isSpeechInProgress = false;
                    resolve();
                };

                try {
                    if (utterance.voice) {
                        speechSynthesis.speak(utterance);
                    } else {
                        console.warn("No valid voice selected for minimal pair speech, cannot speak.");
                        isSpeechInProgress = false;
                        resolve();
                    }
                } catch (e) {
                    console.error("Error calling speechSynthesis.speak (Minimal Pairs):", e);
                    isSpeechInProgress = false;
                    resolve();
                }
            });
        }

        async function speakPairMinimalPairs(word1, word2) {
            await speakWordMinimalPairs(word1);
            await new Promise(resolve => setTimeout(resolve, currentPauseDurationMs));
            await speakWordMinimalPairs(word2);
        }

        async function speakRepeatedlyMinimalPairs(word, count) {
            for (let i = 0; i < count; i++) {
                await speakWordMinimalPairs(word);
                if (i < count - 1) {
                    await new Promise(resolve => setTimeout(resolve, currentPauseDurationMs));
                }
            }
        }

        // Function to show the test modal
        function showTestModalMinimalPairs(pair) {
            modalOption1.textContent = pair[0];
            modalOption2.textContent = pair[1];
            modalFeedback.textContent = ''; // Clear previous feedback
            modalFeedback.className = 'feedback-message'; // Reset class
            modalOption1.style.display = ''; // Ensure buttons are visible
            modalOption2.style.display = ''; // Ensure buttons are visible
            testModal.style.display = 'flex'; // Show the modal
        }

        // Function to check the user's answer
        function checkAnswerMinimalPairs(userAnswer) {
            if (userAnswer === correctWord) {
                modalFeedback.textContent = 'Correct!';
                modalFeedback.classList.add('correct');
            } else {
                modalFeedback.textContent = `Wrong! It was "${correctWord}".`;
                modalFeedback.classList.add('wrong');
            }
            // Hide modal after a short delay
            setTimeout(() => {
                testModal.style.display = 'none';
                modalFeedback.textContent = ''; // Clear feedback for next test
            }, 2000);
        }

        // Event listeners for modal buttons
        modalOption1.addEventListener('click', () => checkAnswerMinimalPairs(modalOption1.textContent));
        modalOption2.addEventListener('click', () => checkAnswerMinimalPairs(modalOption2.textContent));

        function generateButtons(wordData) {
            wordButtonsContainer.innerHTML = '';
            if (!wordData || wordData.length === 0) {
                wordButtonsContainer.innerHTML = '<p>No word data available.</p>';
                return;
            }

            wordData.forEach(categoryObj => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category-container';
                categoryDiv.innerHTML = `<h2>${categoryObj.category}</h2>`;
                wordButtonsContainer.appendChild(categoryDiv);

                const subcategoryArray = categoryObj.subcategories || [];

                subcategoryArray.forEach(subcategoryObj => {
                    const subcategoryDiv = document.createElement('div');
                    subcategoryDiv.className = 'subcategory-container';
                    if (subcategoryObj.name) {
                        subcategoryDiv.innerHTML = `<h3>${subcategoryObj.name}</h3>`;
                    }
                    categoryDiv.appendChild(subcategoryDiv);

                    if (subcategoryObj.description) {
                        const descriptionP = document.createElement('p');
                        descriptionP.textContent = subcategoryObj.description;
                        subcategoryDiv.appendChild(descriptionP);
                    }

                    if (subcategoryObj.contrasts && subcategoryObj.contrasts.length > 0) {
                        subcategoryObj.contrasts.forEach(contrastObj => {
                            const contrastGroupDiv = document.createElement('div');
                            contrastGroupDiv.className = 'contrast-group';
                            const contrastTitle = document.createElement('h4');
                            contrastTitle.textContent = `Contrast: ${contrastObj.description}`;
                            contrastGroupDiv.appendChild(contrastTitle);
                            subcategoryDiv.appendChild(contrastGroupDiv);

                            contrastObj.pairs.forEach(pair => {
                                const pairSectionDiv = document.createElement('div');
                                pairSectionDiv.className = 'pair-section';

                                const pairLabel = document.createElement('span');
                                pairLabel.className = 'pair-label';
                                pairLabel.textContent = `${pair[0]} vs. ${pair[1]}`;
                                pairSectionDiv.appendChild(pairLabel);

                                const buttonPairDiv = document.createElement('div');
                                buttonPairDiv.className = 'button-pair';

                                const button1 = document.createElement('button');
                                button1.textContent = pair[0];
                                button1.setAttribute('data-word1', pair[0]);
                                button1.addEventListener('click', () => speakWordMinimalPairs(pair[0]));
                                buttonPairDiv.appendChild(button1);

                                const button2 = document.createElement('button');
                                button2.textContent = pair[1];
                                button2.setAttribute('data-word2', pair[1]);
                                button2.addEventListener('click', () => speakWordMinimalPairs(pair[1]));
                                buttonPairDiv.appendChild(button2);

                                const speakPairButton = document.createElement('button');
                                speakPairButton.textContent = "Listen Pair";
                                speakPairButton.className = "listen-pair";
                                speakPairButton.setAttribute('data-word-pair-1', pair[0]);
                                speakPairButton.setAttribute('data-word-pair-2', pair[1]);
                                speakPairButton.addEventListener('click', () => speakPairMinimalPairs(pair[0], pair[1]));
                                buttonPairDiv.appendChild(speakPairButton);

                                const testButton = document.createElement('button');
                                testButton.textContent = 'Test';
                                testButton.className = 'test-pair';
                                testButton.addEventListener('click', async () => {
                                    const randomIndex = Math.floor(Math.random() * pair.length);
                                    correctWord = pair[randomIndex];
                                    await speakRepeatedlyMinimalPairs(correctWord, 3);
                                    showTestModalMinimalPairs(pair);
                                });
                                buttonPairDiv.appendChild(testButton);

                                pairSectionDiv.appendChild(buttonPairDiv);
                                contrastGroupDiv.appendChild(pairSectionDiv);
                            });
                        });
                    }
                });
            });
        }

        // --- Event Listeners for new custom text boxes/buttons (Minimal Pairs) ---
        speakFirstWordButton.addEventListener('click', () => {
            speakWordMinimalPairs(textBox1.value);
        });

        speakSecondWordButton.addEventListener('click', () => {
            speakWordMinimalPairs(textBox2.value);
        });

        speakCustomPairButton.addEventListener('click', () => {
            speakPairMinimalPairs(textBox1.value, textBox2.value);
        });

        testCustomPairButton.addEventListener('click', async () => {
            const pair = [textBox1.value, textBox2.value];
            if (!pair[0] || !pair[1]) {
                testModal.style.display = 'flex';
                modalQuestion.textContent = "Please enter both words in the text boxes to use the Test feature.";
                modalOption1.style.display = 'none';
                modalOption2.style.display = 'none';
                modalFeedback.textContent = '';
                setTimeout(() => {
                    testModal.style.display = 'none';
                    modalOption1.style.display = '';
                    modalOption2.style.display = '';
                }, 3000);
                return;
            }
            const randomIndex = Math.floor(Math.random() * pair.length);
            correctWord = pair[randomIndex];

            await speakRepeatedlyMinimalPairs(correctWord, 3);
            showTestModalMinimalPairs(pair);
        });

        // --- Event Listener for Pause Slider ---
        pauseSlider.addEventListener('input', () => {
            currentPauseDurationMs = parseInt(pauseSlider.value);
            pauseValue.textContent = (currentPauseDurationMs / 1000).toFixed(1) + " sec";
        });

        // --- Fix for initial empty space (adjusted for two control bars) ---
        window.addEventListener('load', () => {
            // No form element now, so only stickyControls height matters
            const stickyControlsHeight = stickyControls.offsetHeight;
            mainContentWrapper.style.marginTop = (stickyControlsHeight + 30) + 'px'; // Add some extra space
            console.log("Sticky controls height:", stickyControlsHeight, "px. Set main content margin-top.");
        });

        // Initial call to generate minimal pair buttons when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            generateButtons(embeddedWordData);
        });

    </script>
  </body>
</html>
