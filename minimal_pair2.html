<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Recognition Training</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            margin: 0;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
        }
        h1 {
            color: #0056b3;
            margin: 20px;
            text-align: center;
            font-size: 2.5em;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
        }
        h2, h3, h4 {
            color: #0056b3;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
        }
        .category-container, .subcategory-container, .contrast-group {
            margin: 0 20px 30px 20px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }
        .subcategory-container {
            margin-top: 20px;
            background-color: #f9f9f9;
            border-color: #eee;
            box-shadow: none;
        }
        .contrast-group {
            margin-top: 15px;
            padding: 15px;
            border: 1px dashed #ccc;
            background-color: #fafafa;
            border-radius: 8px;
            display: flex; /* Changed to flex */
            flex-direction: column; /* Stack children vertically */
            align-items: flex-start; /* Align children to the start (left) */
            gap: 15px; /* Space between H4 and first pair-section, and between pair-sections */
        }

        /* New style for the wrapper around each pair's label and buttons */
        .pair-section {
            display: flex;
            flex-direction: column; /* Stack label and buttons vertically */
            gap: 8px; /* Space between label and buttons */
            margin-bottom: 5px; /* Add a little space between different pair sections */
            padding-bottom: 5px; /* Add padding at the bottom of each pair section */
            border-bottom: 1px dotted #eee; /* Subtle separator between pairs */
            width: 100%; /* Ensure it takes full width to enforce stacking */
        }

        /* Remove border-bottom for the last pair-section in a group */
        .contrast-group .pair-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .pair-label {
            font-weight: bold;
            font-size: 1.1em;
            color: #555;
        }

        .button-pair {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px; /* Space between buttons in a pair */
        }
        button {
            padding: 12px 20px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #28a745; /* Green for general actions */
            color: white;
            border: none;
            border-radius: 8px;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        button:hover {
            background-color: #218838;
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        button.listen-pair {
            background-color: #007bff; /* Blue for listen pair */
        }
        button.listen-pair:hover {
            background-color: #0056b3;
        }
        button.test-pair {
            background-color: #ffc107; /* Yellow/Orange for test */
            color: #333;
        }
        button.test-pair:hover {
            background-color: #e0a800;
        }
        select, input[type="text"], input[type="range"] {
            padding: 10px;
            font-size: 1em;
            border-radius: 8px;
            border: 1px solid #ccc;
            margin-right: 10px;
            min-width: 120px;
            box-sizing: border-box;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 180px;
            height: 8px;
            background: #ddd;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 5px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        #pauseValue {
            min-width: 70px;
            text-align: center;
            font-weight: bold;
            color: #0056b3;
        }
        .controls {
            position: sticky;
            top: 0;
            width: 100%;
            background-color: #f4f4f4;
            padding: 15px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
            box-sizing: border-box;
            border-bottom: 1px solid #ddd;
        }
        .controls label {
            white-space: nowrap;
            font-weight: 500;
            color: #555;
        }
        .controls .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        /* Removed file-input-section as it's no longer needed */
        #loadingStatus {
            font-weight: bold;
            color: #dc3545;
            margin-top: 10px;
        }
        #mainContentWrapper {
            margin-top: 0; /* Will be set by JS */
        }

        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            text-align: center;
            max-width: 90%;
            width: 450px;
            animation: fadeIn 0.3s ease-out;
        }

        .modal-content p {
            font-size: 1.4em;
            margin-bottom: 25px;
            color: #333;
            font-weight: 600;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .modal-buttons button {
            flex: 1;
            max-width: 180px;
            padding: 15px 25px;
            font-size: 1.2em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }

        .modal-buttons button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .feedback-message {
            margin-top: 20px;
            font-weight: bold;
            font-size: 1.5em;
            animation: slideIn 0.5s ease-out;
        }

        .feedback-message.correct {
            color: #28a745;
        }

        .feedback-message.wrong {
            color: #dc3545;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
                margin: 15px;
            }
            .category-container, .subcategory-container, .contrast-group {
                margin: 0 10px 20px 10px;
                padding: 15px;
            }
            .controls {
                padding: 10px;
                gap: 10px;
            }
            .controls .control-group {
                flex-direction: column;
                align-items: flex-start;
                width: 100%;
            }
            .controls select, .controls input[type="text"], .controls input[type="range"] {
                width: 100%;
                margin-right: 0;
            }
            .button-pair {
                flex-direction: column;
                width: 100%;
            }
            .button-pair button {
                width: 100%;
                margin: 5px 0;
            }
            .modal-content {
                padding: 20px;
            }
            .modal-buttons {
                flex-direction: column;
                gap: 10px;
            }
            .modal-buttons button {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>

    <div class="controls" id="stickyControls">
        <div class="control-group">
            <label for="voiceSelect">Select Voice:</label>
            <select id="voiceSelect"></select>
        </div>

        <div class="control-group">
            <label for="pauseSlider">Pause:</label>
            <input type="range" id="pauseSlider" min="100" max="3000" value="1000" step="100">
            <span id="pauseValue">1.0 sec</span>
        </div>

        <div class="control-group">
            <label for="textBox1">Word 1:</label>
            <input type="text" id="textBox1" value="Red">
            <label for="textBox2">Word 2:</label>
            <input type="text" id="textBox2" value="Read">
        </div>

        <div class="control-group">
            <button id="speakFirstWordButton" class="play-word">First</button>
            <button id="speakSecondWordButton" class="play-word">Second</button>
            <button id="speakCustomPairButton" class="listen-pair">Listen Pair</button>
            <button id="testCustomPairButton" class="test-pair">Test</button>
        </div>
    </div>

    <div id="mainContentWrapper">
        <h1>Word Recognition Training</h1>

        <div id="wordButtonsContainer">
            <!-- Word categories and buttons will be dynamically loaded here -->
        </div>
    </div>

    <!-- Custom Modal for Test Functionality -->
    <div id="testModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <p id="modalQuestion">Which word did you hear?</p>
            <div class="modal-buttons">
                <button id="modalOption1"></button>
                <button id="modalOption2"></button>
            </div>
            <p id="modalFeedback" class="feedback-message"></p>
        </div>
    </div>

    <script>
        // Embedded JSON Data
        const embeddedWordData = [
            {
                "category": "Initial Consonant",
                "subcategories": [
                    {
                        "name": "Differing by Place (where the sound is made)",
                        "contrasts": [
                            {
                                "description": "/p/ vs. /t/",
                                "pairs": [
                                    ["Pan", "Tan"],
                                    ["Pin", "Tin"],
                                    ["Pot", "Tot"],
                                    ["Pick", "Tick"],
                                    ["Pale", "Tale"],
                                    ["Pat", "Tat"],
                                    ["Pill", "Till"],
                                    ["Pug", "Tug"],
                                    ["Pest", "Test"],
                                    ["Pore", "Tore"],
                                    ["Pea", "Tea"],
                                    ["Pace", "Taste"],
                                    ["Pipe", "Type"],
                                    ["Pool", "Tool"],
                                    ["Pail", "Tail"]
                                ]
                            },
                            {
                                "description": "/b/ vs. /d/",
                                "pairs": [
                                    ["Bat", "Dat"],
                                    ["Big", "Dig"],
                                    ["Bell", "Dell"],
                                    ["Buy", "Dye"],
                                    ["Back", "Dack"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /k/",
                                "pairs": [
                                    ["Pat", "Cat"],
                                    ["Pool", "Cool"],
                                    ["Pear", "Care"],
                                    ["Page", "Cage"]
                                ]
                            },
                            {
                                "description": "/m/ vs. /n/",
                                "pairs": [
                                    ["Mat", "Nat"],
                                    ["Me", "Knee"],
                                    ["Might", "Night"],
                                    ["Met", "Net"]
                                ]
                            },
                            {
                                "description": "/f/ vs. /s/",
                                "pairs": [
                                    ["Fin", "Sin"],
                                    ["Fan", "San"],
                                    ["Fast", "Sass"],
                                    ["Fox", "Socks"]
                                ]
                            },
                            {
                                "description": "/z/ vs. /dʒ/",
                                "pairs": [
                                    ["zest", "jest"],
                                    ["zeal", "jail"]
                                ]
                            },                           
                                                        {
                                "description": "/ʃ/ vs. /s/",
                                "pairs": [
                                    ["Sheep", "Seep"],
                                    ["Shun", "Sun"],
                                    ["Shame", "Same"],
                                    ["Shin", "Sin"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Voicing (vocal cords vibrating or not)",
                        "contrasts": [
                            {
                                "description": "/p/ vs. /b/",
                                "pairs": [
                                    ["Pat", "Bat"],
                                    ["Pig", "Big"],
                                    ["Pin", "Bin"],
                                    ["Pie", "Buy"],
                                    ["Pit", "Bit"]
                                ]
                            },
                            {
                                "description": "/t/ vs. /d/",
                                "pairs": [
                                    ["To", "Do"],
                                    ["Tip", "Dip"],
                                    ["Ten", "Den"],
                                    ["Tie", "Die"]
                                ]
                            },
                            {
                                "description": "/k/ vs. /g/",
                                "pairs": [
                                    ["Cat", "Gat"],
                                    ["Cut", "Gut"],
                                    ["Kiss", "Guess"],
                                    ["Came", "Game"]
                                ]
                            },
                            {
                                "description": "/f/ vs. /v/",
                                "pairs": [
                                    ["Fan", "Van"],
                                    ["Fine", "Vine"],
                                    ["Fat", "Vat"],
                                    ["Few", "View"]
                                ]
                            },
                            {
                                "description": "/s/ vs. /z/",
                                "pairs": [
                                    ["Seal", "Zeal"],
                                    ["Sink", "Zink"],
                                    ["Sip", "Zip"]
                                ]
                            },
                            {
                                "description": "/θ/ vs. /ð/",
                                "pairs": [
                                    ["Thin", "Then"],
                                    ["Thigh", "Thy"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Manner (how the air flows)",
                        "contrasts": [
                            {
                                "description": "/p/ (Stop) vs. /f/ (Fricative)",
                                "pairs": [
                                    ["Pan", "Fan"],
                                    ["Pat", "Fat"],
                                    ["Pill", "Fill"]
                                ]
                            },
                            {
                                "description": "/d/ (Stop) vs. /n/ (Nasal)",
                                "pairs": [
                                    ["Den", "Nen"],
                                    ["Dare", "Nair"]
                                ]
                            },
                            {
                                "description": "/tʃ/ (Affricate) vs. /ʃ/ (Fricative)",
                                "pairs": [
                                    ["Cheer", "Shear"],
                                    ["Chip", "Ship"],
                                    ["Chop", "Shop"]
                                ]
                            },
                            {
                                "description": "/dʒ/ (Affricate) vs. /z/ (Fricative)",
                                "pairs": [
                                    ["jag", "zag"],
                                    ["jeep", "zeep"],
                                    ["jest", "zest"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Final Consonant",
                "subcategories": [
                    {
                        "name": "Differing by Voicing",
                        "contrasts": [
                            {
                                "description": "/t/ vs. /d/ (Alveolar Stop)",
                                "pairs": [
                                    ["Beat", "Bead"],
                                    ["Hat", "Had"],
                                    ["Sit", "Sid"],
                                    ["Pat", "Pad"],
                                    ["Bet", "Bed"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /b/ (Bilabial Stop)",
                                "pairs": [
                                    ["Cap", "Cab"],
                                    ["Rip", "Rib"],
                                    ["Tap", "Tab"]
                                ]
                            },
                            {
                                "description": "/k/ vs. /g/ (Velar Stop)",
                                "pairs": [
                                    ["Back", "Bag"],
                                    ["Lock", "Log"],
                                    ["Pick", "Pig"]
                                ]
                            },
                            {
                                "description": "/s/ vs. /z/ (Alveolar Fricative)",
                                "pairs": [
                                    ["Peace", "Peas"],
                                    ["Race", "Raise"],
                                    ["Bus", "Buzz"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Place",
                        "contrasts": [
                            {
                                "description": "/m/ vs. /n/ (Nasal)",
                                "pairs": [
                                    ["Swim", "Swin"],
                                    ["Team", "Teen"]
                                ]
                            },
                            {
                                "description": "/n/ vs. /ŋ/ (Alveolar vs. Velar Nasal)",
                                "pairs": [
                                    ["Sin", "Sing"],
                                    ["Ran", "Rang"],
                                    ["Win", "Wing"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Manner",
                        "contrasts": [
                            {
                                "description": "/t/ (Stop) vs. /s/ (Fricative)",
                                "pairs": [
                                    ["Hat", "Hass"],
                                    ["Pat", "Pass"]
                                ]
                            },
                            {
                                "description": "/d/ (Stop) vs. /z/ (Fricative)",
                                "pairs": [
                                    ["Aid", "Aze"],
                                    ["Bid", "Biz"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Vowels",
                "subcategories": [
                    {
                        "name": "Short vs. Long/Tense Vowels",
                        "contrasts": [
                            {
                                "description": "/ɪ/ (short i) vs. /iː/ (long e)",
                                "pairs": [
                                    ["Bin", "Bean"],
                                    ["Fit", "Feet"],
                                    ["Lip", "Leap"],
                                    ["Sip", "Seep"],
                                    ["Dill", "Deal"]
                                ]
                            },
                            {
                                "description": "/æ/ (short a) vs. /ɑː/ (broad a)",
                                "pairs": [
                                    ["Cat", "Cart"],
                                    ["Bad", "Bard"]
                                ]
                            },
                            {
                                "description": "/ʊ/ (short u) vs. /uː/ (long oo)",
                                "pairs": [
                                    ["Look", "Luke"],
                                    ["Pull", "Pool"],
                                    ["Should", "Shooed"]
                                ]
                            },
                            {
                                "description": "/ɛ/ (short e) vs. /eɪ/ (long a)",
                                "pairs": [
                                    ["Met", "Mate"],
                                    ["Wet", "Wait"],
                                    ["Sell", "Sail"],
                                    ["Bed", "Bade"]
                                ]
                            },
                            {
                                "description": "/ʌ/ (short u as in 'cut') vs. /ɔː/ (aw as in 'caught')",
                                "pairs": [
                                    ["Cut", "Caught"],
                                    ["Duck", "Dock"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Front vs. Back Vowels",
                        "contrasts": [
                            {
                                "description": "/iː/ (long e) vs. /uː/ (long oo)",
                                "pairs": [
                                    ["Feel", "Fool"],
                                    ["Leave", "Looze"]
                                ]
                            },
                            {
                                "description": "/æ/ (short a) vs. /ɑː/ (broad a)",
                                "pairs": [
                                    ["Cab", "Cob"],
                                    ["Cat", "Cot"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Monophthongs vs. Diphthongs",
                        "contrasts": [
                            {
                                "description": "/ɑː/ (broad a) vs. /aɪ/ (long i)",
                                "pairs": [
                                    ["Dad", "Died"],
                                    ["Cop", "Cope"]
                                ]
                            },
                            {
                                "description": "/ɔː/ (aw) vs. /oʊ/ (long o)",
                                "pairs": [
                                    ["Cot", "Coat"],
                                    ["Not", "Note"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Consonant Clusters",
                "subcategories": [
                    {
                        "name": "Initial Clusters",
                        "contrasts": [
                            {
                                "description": "/s/ vs. /st/",
                                "pairs": [
                                    ["Sit", "Stir"],
                                    ["Sip", "Stripe"]
                                ]
                            },
                            {
                                "description": "/l/ vs. /sl/",
                                "pairs": [
                                    ["Led", "Sled"],
                                    ["Light", "Slight"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /sp/",
                                "pairs": [
                                    ["Pin", "Spin"],
                                    ["Peak", "Speak"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Final Clusters",
                        "contrasts": [
                            {
                                "description": "/mp/ vs. /nt/",
                                "pairs": [
                                    ["Camp", "Cant"],
                                    ["Dump", "Dunt"]
                                ]
                            },
                            {
                                "description": "/st/ vs. /sk/",
                                "pairs": [
                                    ["Last", "Lask"],
                                    ["Test", "Tesk"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Medial Consonant",
                "subcategories": [
                    {
                        "name": "Voicing",
                        "contrasts": [
                            {
                                "description": "/t/ vs. /d/",
                                "pairs": [
                                    ["Meta", "Medal"],
                                    ["City", "Cider"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Place",
                        "contrasts": [
                            {
                                "description": "/n/ vs. /m/",
                                "pairs": [
                                    ["Winner", "Whimper"],
                                    ["Denim", "Demin"]
                                ]
                            }
                        ]
                    }
                ]
            }
        ];

        // --- Web Speech API Logic ---
        if ('speechSynthesis' in window) {
            const synth = window.speechSynthesis;
            const wordButtonsContainer = document.getElementById('wordButtonsContainer');
            const voiceSelect = document.getElementById('voiceSelect');

            const textBox1 = document.getElementById('textBox1');
            const textBox2 = document.getElementById('textBox2');
            const speakFirstWordButton = document.getElementById('speakFirstWordButton');
            const speakSecondWordButton = document.getElementById('speakSecondWordButton');
            const speakCustomPairButton = document.getElementById('speakCustomPairButton');
            const testCustomPairButton = document.getElementById('testCustomPairButton'); // Custom test button

            const pauseSlider = document.getElementById('pauseSlider');
            const pauseValue = document.getElementById('pauseValue');
            const stickyControls = document.getElementById('stickyControls');
            const mainContentWrapper = document.getElementById('mainContentWrapper');

            // Modal elements
            const testModal = document.getElementById('testModal');
            const modalQuestion = document.getElementById('modalQuestion');
            const modalOption1 = document.getElementById('modalOption1');
            const modalOption2 = document.getElementById('modalOption2');
            const modalFeedback = document.getElementById('modalFeedback');

            let availableVoices = [];
            let currentPauseDurationMs = parseInt(pauseSlider.value);
            let correctWord = ''; // Variable to store the correct word for the test

            // Flag to manage speech state
            let isSpeechInProgress = false;

            // --- Voice Loading Retry Variables ---
            let voiceLoadRetries = 0;
            const MAX_VOICE_RETRIES = 10; // Try up to 10 times
            const VOICE_RETRY_DELAY = 200; // Wait 200ms between retries

            function populateVoiceList() {
                availableVoices = synth.getVoices().sort((a, b) => {
                    const aname = a.name.toUpperCase();
                    const bname = b.name.toUpperCase();
                    if (aname < bname) return -1;
                    if (aname > bname) return +1;
                    return 0;
                });

                // --- Retry logic for Firefox and other browsers where voices might not be immediately available ---
                if (availableVoices.length === 0 && voiceLoadRetries < MAX_VOICE_RETRIES) {
                    console.warn("No voices available yet, retrying...", voiceLoadRetries + 1);
                    voiceLoadRetries++;
                    setTimeout(populateVoiceList, VOICE_RETRY_DELAY); // Retry after a short delay
                    return; // Exit this call, wait for retry
                } else if (availableVoices.length === 0 && voiceLoadRetries >= MAX_VOICE_RETRIES) {
                    console.error("Failed to load voices after multiple retries. Please try refreshing or ensure voices are installed.");
                    voiceSelect.innerHTML = '<option value="">No Voices Available</option>'; // Show a message
                    return; // Stop trying
                }
                // --- End Retry ---

                voiceSelect.innerHTML = '';
                let defaultVoiceFound = false;

                availableVoices.forEach((voice, index) => {
                    const option = document.createElement('option');
                    option.textContent = `${voice.name} (${voice.lang})`;
                    // Store the index of the voice in the availableVoices array
                    option.setAttribute('data-index', index); 

                    // Attempt to select a default voice (e.g., en-US)
                    if (voice.lang === 'en-US' && !defaultVoiceFound) {
                        option.selected = true;
                        defaultVoiceFound = true;
                    }

                    voiceSelect.appendChild(option);
                });

                // If no en-US voice was found, try en-GB as a fallback
                if (!defaultVoiceFound) {
                    const enGBVoiceIndex = availableVoices.findIndex(voice => voice.lang === 'en-GB');
                    if (enGBVoiceIndex !== -1) {
                        // Select the option corresponding to the en-GB voice
                        voiceSelect.querySelector(`option[data-index="${enGBVoiceIndex}"]`).selected = true;
                        defaultVoiceFound = true; // Mark as found
                    }
                }
                
                // If still no default, just select the first available voice
                if (!defaultVoiceFound && availableVoices.length > 0) {
                    voiceSelect.options[0].selected = true;
                }

                console.log("Voice list populated. Total voices:", availableVoices.length);
                voiceLoadRetries = 0; // Reset retry counter on success
            }

            // Event listener for voices changed (standard approach)
            if (synth.onvoiceschanged !== undefined) {
                synth.onvoiceschanged = populateVoiceList;
            }

            // Initial call to populate. If voices aren't ready, the retry logic handles it.
            populateVoiceList();

            // Event listener for voice selection change
            voiceSelect.addEventListener('change', () => {
                // No need to update selectedVoice directly here, as getSelectedVoice will use the dropdown's current selection
            });

            // Modified getSelectedVoice to use the direct index
            function getSelectedVoice() {
                const selectedOption = voiceSelect.selectedOptions[0];
                const voiceIndex = parseInt(selectedOption.getAttribute('data-index'));
                // Return the voice object directly from the availableVoices array using its stored index
                return availableVoices[voiceIndex];
            }

            // New helper function to wait for speech to stop
            async function waitForSpeechToStop() {
                // If speech is already in progress, cancel it
                if (synth.speaking) {
                    synth.cancel();
                }
                // Poll until speech is no longer in progress
                while (synth.speaking) {
                    await new Promise(resolve => setTimeout(resolve, 50)); // Check every 50ms
                }
                isSpeechInProgress = false; // Ensure flag is reset after stopping
            }

            async function speakWord(word) {
                return new Promise(async (resolve) => {
                    await waitForSpeechToStop(); // Ensure previous speech is fully stopped

                    isSpeechInProgress = true; // Set flag to indicate speech is in progress

                    const utterance = new SpeechSynthesisUtterance(word);
                    utterance.voice = getSelectedVoice(); // Now uses the more robust selection
                    utterance.pitch = 1;
                    utterance.rate = 1;

                    utterance.onend = () => {
                        isSpeechInProgress = false; // Reset flag when speech ends
                        resolve();
                    };
                    utterance.onerror = (event) => {
                        console.error('SpeechSynthesisUtterance.onerror', event.error, `Word: "${word}"`);
                        isSpeechInProgress = false; // Reset flag on error
                        resolve(); // Always resolve the promise to prevent blocking
                    };

                    try {
                        // Only speak if a valid voice is selected
                        if (utterance.voice) {
                            synth.speak(utterance);
                        } else {
                            console.warn("No valid voice selected, cannot speak.");
                            isSpeechInProgress = false;
                            resolve();
                        }
                    } catch (e) {
                        console.error("Error calling synth.speak:", e);
                        isSpeechInProgress = false; // Reset flag on immediate error
                        resolve(); // Always resolve the promise
                    }
                });
            }

            async function speakPair(word1, word2) {
                await speakWord(word1);
                await new Promise(resolve => setTimeout(resolve, currentPauseDurationMs));
                await speakWord(word2);
            }

            // Function to speak a word repeatedly with pauses
            async function speakRepeatedly(word, count) {
                for (let i = 0; i < count; i++) {
                    await speakWord(word);
                    if (i < count - 1) { // Don't pause after the last word
                        await new Promise(resolve => setTimeout(resolve, currentPauseDurationMs));
                    }
                }
            }

            // Function to show the test modal
            function showTestModal(pair) {
                modalOption1.textContent = pair[0];
                modalOption2.textContent = pair[1];
                modalFeedback.textContent = ''; // Clear previous feedback
                modalFeedback.className = 'feedback-message'; // Reset class
                modalOption1.style.display = ''; // Ensure buttons are visible
                modalOption2.style.display = ''; // Ensure buttons are visible
                testModal.style.display = 'flex'; // Show the modal
            }

            // Function to check the user's answer
            function checkAnswer(userAnswer) {
                if (userAnswer === correctWord) {
                    modalFeedback.textContent = 'Correct!';
                    modalFeedback.classList.add('correct');
                } else {
                    modalFeedback.textContent = `Wrong! It was "${correctWord}".`;
                    modalFeedback.classList.add('wrong');
                }
                // Hide modal after a short delay
                setTimeout(() => {
                    testModal.style.display = 'none';
                    modalFeedback.textContent = ''; // Clear feedback for next test
                }, 2000);
            }

            // Event listeners for modal buttons
            modalOption1.addEventListener('click', () => checkAnswer(modalOption1.textContent));
            modalOption2.addEventListener('click', () => checkAnswer(modalOption2.textContent));


            function generateButtons(wordData) {
                wordButtonsContainer.innerHTML = '';
                if (!wordData || wordData.length === 0) {
                    wordButtonsContainer.innerHTML = '<p>No word data available.</p>';
                    return;
                }

                wordData.forEach(categoryObj => {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'category-container';
                    categoryDiv.innerHTML = `<h2>${categoryObj.category}</h2>`;
                    wordButtonsContainer.appendChild(categoryDiv);

                    const subcategoryArray = categoryObj.subcategories || []; // Ensure subcategories is an array

                    subcategoryArray.forEach(subcategoryObj => {
                        const subcategoryDiv = document.createElement('div');
                        subcategoryDiv.className = 'subcategory-container';
                        if (subcategoryObj.name) {
                            subcategoryDiv.innerHTML = `<h3>${subcategoryObj.name}</h3>`;
                        }
                        categoryDiv.appendChild(subcategoryDiv);

                        if (subcategoryObj.description) { // Add description if it exists
                            const descriptionP = document.createElement('p');
                            descriptionP.textContent = subcategoryObj.description;
                            subcategoryDiv.appendChild(descriptionP);
                        }

                        // Check if contrastObj and contrastObj.description exist before proceeding
                        if (subcategoryObj.contrasts && subcategoryObj.contrasts.length > 0) {
                            subcategoryObj.contrasts.forEach(contrastObj => {
                                const contrastGroupDiv = document.createElement('div');
                                contrastGroupDiv.className = 'contrast-group';
                                const contrastTitle = document.createElement('h4'); // Create h4 element for contrast description
                                contrastTitle.textContent = `Contrast: ${contrastObj.description}`;
                                contrastGroupDiv.appendChild(contrastTitle); // Append h4 to contrastGroupDiv
                                subcategoryDiv.appendChild(contrastGroupDiv); // Append contrastGroupDiv to subcategoryDiv

                                contrastObj.pairs.forEach(pair => {
                                    const pairSectionDiv = document.createElement('div'); // New wrapper for each pair's label and buttons
                                    pairSectionDiv.className = 'pair-section';

                                    const pairLabel = document.createElement('span');
                                    pairLabel.className = 'pair-label'; // Add class for styling
                                    pairLabel.textContent = `${pair[0]} vs. ${pair[1]}`;
                                    pairSectionDiv.appendChild(pairLabel);

                                    const buttonPairDiv = document.createElement('div');
                                    buttonPairDiv.className = 'button-pair'; // Keep this for the buttons themselves

                                    const button1 = document.createElement('button');
                                    button1.textContent = pair[0];
                                    button1.setAttribute('data-word1', pair[0]);
                                    button1.addEventListener('click', () => speakWord(pair[0]));
                                    buttonPairDiv.appendChild(button1);

                                    const button2 = document.createElement('button');
                                    button2.textContent = pair[1];
                                    button2.setAttribute('data-word2', pair[1]);
                                    button2.addEventListener('click', () => speakWord(pair[1]));
                                    buttonPairDiv.appendChild(button2);

                                    const speakPairButton = document.createElement('button');
                                    speakPairButton.textContent = "Listen Pair";
                                    speakPairButton.className = "listen-pair";
                                    speakPairButton.setAttribute('data-word-pair-1', pair[0]);
                                    speakPairButton.setAttribute('data-word-pair-2', pair[1]);
                                    speakPairButton.addEventListener('click', () => speakPair(pair[0], pair[1]));
                                    buttonPairDiv.appendChild(speakPairButton);

                                    // Test button for dynamically loaded pairs
                                    const testButton = document.createElement('button');
                                    testButton.textContent = 'Test';
                                    testButton.className = 'test-pair';
                                    testButton.addEventListener('click', async () => {
                                        const randomIndex = Math.floor(Math.random() * pair.length);
                                        correctWord = pair[randomIndex];
                                        await speakRepeatedly(correctWord, 3);
                                        showTestModal(pair);
                                    });
                                    buttonPairDiv.appendChild(testButton); // Append the test button

                                    pairSectionDiv.appendChild(buttonPairDiv); // Append buttonPairDiv to pairSectionDiv
                                    contrastGroupDiv.appendChild(pairSectionDiv); // Append pairSectionDiv to contrastGroupDiv
                                }); // End of pairs.forEach
                            }); // End of contrasts.forEach
                        }
                    }); // End of subcategoryArray.forEach
                }); // End of wordData.forEach
            }


            // --- Event Listeners for new custom text boxes/buttons ---
            speakFirstWordButton.addEventListener('click', () => {
                speakWord(textBox1.value);
            });

            speakSecondWordButton.addEventListener('click', () => {
                speakWord(textBox2.value);
            });

            speakCustomPairButton.addEventListener('click', () => {
                speakPair(textBox1.value, textBox2.value);
            });

            // --- Event Listener for custom test button in controls bar ---
            testCustomPairButton.addEventListener('click', async () => {
                const pair = [textBox1.value, textBox2.value];
                if (!pair[0] || !pair[1]) {
                    // Using a custom modal/message box instead of alert()
                    testModal.style.display = 'flex';
                    modalQuestion.textContent = "Please enter both words in the text boxes to use the Test feature.";
                    modalOption1.style.display = 'none'; // Hide buttons
                    modalOption2.style.display = 'none';
                    modalFeedback.textContent = '';
                    setTimeout(() => {
                        testModal.style.display = 'none';
                        modalOption1.style.display = ''; // Show buttons again for next use
                        modalOption2.style.display = '';
                    }, 3000);
                    return;
                }
                const randomIndex = Math.floor(Math.random() * pair.length);
                correctWord = pair[randomIndex];

                await speakRepeatedly(correctWord, 3);
                showTestModal(pair);
            });


            // --- Event Listener for Pause Slider ---
            pauseSlider.addEventListener('input', () => {
                currentPauseDurationMs = parseInt(pauseSlider.value);
                pauseValue.textContent = (currentPauseDurationMs / 1000).toFixed(1) + " sec";
            });

            // --- Fix for initial empty space ---
            window.addEventListener('load', () => {
                const controlsHeight = stickyControls.offsetHeight;
                mainContentWrapper.style.marginTop = controlsHeight + 'px';
                console.log("Sticky controls height:", controlsHeight, "px. Set main content margin-top.");
            });

            // --- Event Delegation for Dynamically Generated Buttons (for single words and listen pairs) ---
            wordButtonsContainer.addEventListener('click', (event) => {
                const target = event.target;
                if (target.tagName === 'BUTTON') {
                    // Check if it's a single word button (not a pair button)
                    if (target.hasAttribute('data-word1') && !target.classList.contains('listen-pair') && !target.classList.contains('test-pair')) {
                        speakWord(target.getAttribute('data-word1'));
                    } else if (target.hasAttribute('data-word2') && !target.classList.contains('listen-pair') && !target.classList.contains('test-pair')) {
                        speakWord(target.getAttribute('data-word2'));
                    }
                    // The 'listen-pair' and 'test-pair' buttons have their own direct event listeners now
                    // within the generateButtons function, so delegation for them is less critical here.
                }
            });

            // Initial call to generate buttons with embedded data when the DOM is ready
            document.addEventListener('DOMContentLoaded', () => {
                generateButtons(embeddedWordData);
            });

        } else {
            // Fallback for browsers that do not support Web Speech API
            testModal.style.display = 'flex';
            modalQuestion.textContent = 'Your browser does not support the Web Speech API. Please try a different browser (e.g., Chrome, Edge, Firefox).';
            // Hide modal buttons if speech API is not supported
            document.querySelector('.modal-buttons').style.display = 'none';
            modalFeedback.textContent = '';
        }
    </script>
</body>
</html>
