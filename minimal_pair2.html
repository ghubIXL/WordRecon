<html>
  <head>
    <title>Word Recognition Training</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #f4f4f4; /* Light background for overall page */
        color: #333;
        line-height: 1.6;
        margin: 0;
        padding: 0; /* Remove body padding, apply to inner container for flexbox */
        box-sizing: border-box;
        display: flex; /* Use flexbox for overall layout */
        flex-direction: column; /* Stack children vertically */
        min-height: 100vh; /* Ensure body takes full viewport height */
      }
      .app-container { /* New container to hold all visible content */
        display: flex;
        flex-direction: column;
        flex-grow: 1; /* Allows this container to fill available vertical space */
        /* Removed padding here, apply to inner sections to keep them within their flex-basis */
        box-sizing: border-box;
        max-width: 840px; /* Consistent max-width for both sections + padding */
        margin: 0 auto; /* Center the entire app container */
        height: 100vh; /* Ensure it takes full viewport height */
        padding: 20px; /* Padding for the entire app container */
        gap: 20px; /* Space between controls and mainContentWrapper */
      }
      h1 {
        color: #0056b3;
        margin: 0 auto 20px auto; /* Center heading, add bottom margin */
        text-align: center;
        font-size: 2.5em;
        border-bottom: 2px solid #0056b3;
        padding-bottom: 10px;
        width: 100%; /* Ensure heading takes full width of app-container */
      }
      h2, h3, h4 {
        color: #0056b3;
        margin-top: 25px;
        margin-bottom: 15px;
        font-weight: 600;
      }

      /* Base button and select styles for consistency */
      button, select {
        background-color: #fff;
        border: none;
        border-radius: 8px;
        height: 2.5rem;
        padding: 0 15px;
        font-size: 1em;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      }
      select {
       -webkit-appearance: none;
       -moz-appearance: none;
       appearance: none;
       padding-right: 30px;
     }

     input[type=range] {
      -moz-appearance: none;
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      background: #ddd;
      outline: none;
      opacity: 0.7;
      transition: opacity .2s;
      border-radius: 5px;
     }
     input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #007bff;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
     }
     input[type=range]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #007bff;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
     }
     input[type=range]::-ms-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
     }
     input[type=range]::-ms-track {
        background: transparent;
        border-color: transparent;
        color: transparent;
     }
     input[type=range]::-ms-fill-lower {
        background: #ddd;
        border-radius: 5px;
     }
     input[type=range]::-ms-fill-upper {
        background: #ddd;
        border-radius: 5px;
     }

      /* Top Controls Section - General Styling */
      .controls {
          width: 100%;
          flex-basis: 33.33%; /* Occupy 1/3 of parent's height */
          flex-shrink: 0; /* Prevent shrinking */
          overflow-y: auto; /* Enable vertical scrolling */
          background-color: #fff; /* Match lower section background */
          padding: 15px 20px;
          border: 1px solid #ddd; /* Match lower section border */
          border-radius: 10px; /* Match lower section border-radius */
          box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); /* Match lower section shadow */
          z-index: 1000;
          display: flex;
          flex-direction: column; /* Stack control groups vertically */
          gap: 5px; /* Smaller gap between control groups */
          box-sizing: border-box;
          /* Removed margin-bottom as gap handles spacing in app-container */
      }
      .controls .control-group:last-of-type {
        margin-bottom: 0; /* No margin after the last group */
      }

      /* Top Controls - Compact Group Styling */
      .controls .control-group {
        display: flex;
        align-items: center;
        gap: 8px; /* Gap between elements in a group */
        margin-bottom: 8px; /* Smaller margin between control groups */
      }
      .controls .control-group label {
        white-space: nowrap;
        font-weight: 500;
        color: #555;
        flex-shrink: 0; /* Prevent label from shrinking */
        width: auto; /* Allow label to take natural width */
        min-width: 50px; /* Minimum width for labels */
      }
      .controls .control-group select,
      .controls .control-group input[type="text"],
      .controls .control-group input[type="range"] {
        flex-grow: 1; /* Allow inputs to take remaining space */
        height: 2rem; /* Compact height */
        padding: 4px 8px; /* Compact padding */
        font-size: 0.85em; /* Smaller font size */
        border: 1px solid #ccc; /* Add border for text inputs/select */
        border-radius: 5px; /* Slightly less rounded for compactness */
      }
      .controls .control-group span { /* For value labels (1.0, 1.0 sec) */
        white-space: nowrap;
        font-size: 0.85em;
        font-weight: bold;
        color: #0056b3;
        flex-shrink: 0; /* Prevent from shrinking */
        min-width: 40px; /* Give some minimum space */
        text-align: right;
      }

      /* Reset Button Styling (Matching lower section buttons) */
      .controls .control-group button.reset-button {
        height: 2rem; /* Match input height */
        width: auto; /* Auto width for text */
        padding: 4px 10px; /* Padding for text */
        font-size: 0.85em; /* Match input font size */
        background-color: #6c757d; /* Grey for reset */
        color: white;
        border-radius: 6px; /* Match lower section button radius */
        box-shadow: 0 3px 6px rgba(0,0,0,0.1); /* Match lower section shadow */
        transition: background-color 0.2s ease, transform 0.1s ease;
      }
      .controls .control-group button.reset-button:hover {
        background-color: #5a6268;
        transform: translateY(-1px);
      }

      /* Top Section Action Buttons (Word 1, Word 2, First, Second, Listen Pair, Test) */
      .controls .control-group button.play-word,
      .controls .control-group button.listen-pair,
      .controls .control-group button.test-pair {
        padding: 10px 15px; /* Match lower section buttons */
        font-size: 0.95em; /* Match lower section buttons */
        border-radius: 6px; /* Match lower section buttons */
        height: auto; /* Auto height for text content */
        background-color: #28a745; /* Default green */
        color: white;
        box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        flex-grow: 1; /* Allow them to grow within their group */
        min-width: unset; /* Remove min-width inherited from general button */
      }
      .controls .control-group button.play-word:hover,
      .controls .control-group button.listen-pair:hover,
      .controls .control-group button.test-pair:hover {
        background-color: #218838;
        transform: translateY(-1px);
      }
      .controls .control-group button.listen-pair {
          background-color: #007bff;
      }
      .controls .control-group button.listen-pair:hover {
          background-color: #0056b3;
      }
      .controls .control-group button.test-pair {
          background-color: #ffc107;
          color: #333;
      }
      .controls .control-group button.test-pair:hover {
          background-color: #e0a800;
      }


      /* Minimal Pair Section (Bottom) - Existing styles, ensuring consistency */
      #mainContentWrapper {
          flex-basis: 66.66%; /* Occupy 2/3 of parent's height */
          flex-grow: 1; /* Allows content to take remaining vertical space */
          overflow-y: auto; /* Allows content to scroll independently */
          padding-top: 5px; /* Small padding at the top of the scrollable area */
          box-sizing: border-box; /* Include padding/border in width */
      }
      .category-container, .subcategory-container, .contrast-group {
          margin: 0 auto 30px auto;
          padding: 20px;
          border: 1px solid #ddd;
          border-radius: 10px;
          background-color: #fff;
          box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
          width: 100%; /* Ensure they take full width of mainContentWrapper */
          box-sizing: border-box; /* Include padding/border in width */
      }
      .subcategory-container {
          margin-top: 20px;
          background-color: #f9f9f9;
          border-color: #eee;
          box-shadow: none;
      }
      .contrast-group {
          margin-top: 15px;
          padding: 15px;
          border: 1px dashed #ccc;
          background-color: #fafafa;
          border-radius: 8px;
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 15px;
      }
      .pair-section {
          display: flex;
          flex-direction: column;
          gap: 8px;
          margin-bottom: 5px;
          padding-bottom: 5px;
          border-bottom: 1px dotted #eee;
          width: 100%;
      }
      .contrast-group .pair-section:last-child {
          border-bottom: none;
          margin-bottom: 0;
          padding-bottom: 0;
      }
      .pair-label {
          font-weight: bold;
          font-size: 1.1em;
          color: #555;
      }
      .button-pair {
          display: flex;
          align-items: center;
          flex-wrap: wrap;
          gap: 10px;
      }
      .button-pair button {
          padding: 10px 15px;
          font-size: 0.95em;
          border-radius: 6px;
          height: auto;
          background-color: #28a745;
          color: white;
          box-shadow: 0 3px 6px rgba(0,0,0,0.1);
      }
      .button-pair button:hover {
          background-color: #218838;
          transform: translateY(-1px);
      }
      /* Specific colors for listen/test buttons in lower section */
      .button-pair button.listen-pair {
          background-color: #007bff;
      }
      .button-pair button.listen-pair:hover {
          background-color: #0056b3;
      }
      .button-pair button.test-pair {
          background-color: #ffc107;
          color: #333;
      }
      .button-pair button.test-pair:hover {
          background-color: #e0a800;
      }

      #pauseValue {
          min-width: 70px;
          text-align: center;
          font-weight: bold;
          color: #0056b3;
      }

      #loadingStatus {
          font-weight: bold;
          color: #dc3545;
          margin-top: 10px;
      }

      /* Custom Modal Styles (unchanged) */
      .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 2000;
      }

      .modal-content {
          background-color: #fff;
          padding: 30px;
          border-radius: 10px;
          box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
          text-align: center;
          max-width: 90%;
          width: 450px;
          animation: fadeIn 0.3s ease-out;
      }

      .modal-content p {
          font-size: 1.4em;
          margin-bottom: 25px;
          color: #333;
          font-weight: 600;
      }

      .modal-buttons {
          display: flex;
          justify-content: center;
          gap: 20px;
          margin-bottom: 20px;
      }

      .modal-buttons button {
          flex: 1;
          max-width: 180px;
          padding: 15px 25px;
          font-size: 1.2em;
          background-color: #007bff;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          transition: background-color 0.2s ease, transform 0.1s ease;
          box-shadow: 0 3px 6px rgba(0,0,0,0.1);
      }

      .modal-buttons button:hover {
          background-color: #0056b3;
          transform: translateY(-1px);
      }

      .feedback-message {
          margin-top: 20px;
          font-weight: bold;
          font-size: 1.5em;
          animation: slideIn 0.5s ease-out;
      }

      .feedback-message.correct {
          color: #28a745;
      }

      .feedback-message.wrong {
          color: #dc3545;
      }

      @keyframes fadeIn {
          from { opacity: 0; transform: translateY(-20px); }
          to { opacity: 1; transform: translateY(0); }
      }

      @keyframes slideIn {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
      }
      /* Responsive adjustments */
      @media (max-width: 768px) {
          h1 {
              font-size: 2em;
              margin: 15px;
          }
          .category-container, .subcategory-container, .contrast-group {
              margin: 0 10px 20px 10px;
              padding: 15px;
          }
          .controls {
              padding: 10px;
              gap: 10px;
          }
          .controls .control-group {
              flex-direction: column;
              align-items: flex-start;
              width: 100%;
          }
          .controls select, .controls input[type="text"], .controls input[type="range"] {
              width: 100%;
              margin-right: 0;
          }
          .button-pair {
              flex-direction: column;
              width: 100%;
          }
          .button-pair button {
              width: 100%;
              margin: 5px 0;
          }
          .modal-content {
              padding: 20px;
          }
          .modal-buttons {
              flex-direction: column;
              gap: 10px;
          }
          .modal-buttons button {
              max-width: 100%;
          }
      }
    </style>
  </head>
  <body class="loading">
    <div class="app-container">
        <h1>Word Recognition Training</h1>

        <!-- Top Controls Section -->
        <div class="controls" id="stickyControls">
            <div class="control-group">
                <label for="voiceSelect">Select Voice:</label>
                <select id="voiceSelect"></select>
            </div>

            <div class="control-group">
                <label for="pitchSlider">Pitch:</label>
                <input id="pitchSlider" type="range" value="1" min="0" max="2" step="0.1">
                <span id="pitchValue">1.0</span>
                <button type="button" class="reset-button" aria-label="Reset pitch" title="Reset pitch" onclick="resetPitch();">Reset</button>
            </div>
            <div class="control-group">
                <label for="rateSlider">Rate:</label>
                <input id="rateSlider" type="range" value="1" min="0.1" max="10" step="0.1">
                <span id="rateValue">1.0</span>
                <button type="button" class="reset-button" aria-label="Reset rate" title="Reset rate" onclick="resetRate();">Reset</button>
            </div>
            <div class="control-group">
                <label for="volumeSlider">Volume:</label>
                <input id="volumeSlider" type="range" value="1" min="0" max="1" step="0.05">
                <span id="volumeValue">1.0</span>
                <button type="button" class="reset-button" aria-label="Reset volume" title="Reset volume" onclick="resetVolume();">Reset</button>
            </div>

            <div class="control-group">
                <label for="pauseSlider">Pause:</label>
                <input type="range" id="pauseSlider" min="100" max="3000" value="1000" step="100">
                <span id="pauseValue">1.0 sec</span>
            </div>

            <div class="control-group">
                <label for="textBox1">Word 1:</label>
                <input type="text" id="textBox1" value="Red">
                <label for="textBox2">Word 2:</label>
                <input type="text" id="textBox2" value="Read">
            </div>

            <div class="control-group">
                <button id="speakFirstWordButton" class="play-word">First</button>
                <button id="speakSecondWordButton" class="play-word">Second</button>
                <button id="speakCustomPairButton" class="listen-pair">Listen Pair</button>
                <button id="testCustomPairButton" class="test-pair">Test</button>
            </div>
        </div>

        <div id="mainContentWrapper">
            <div id="wordButtonsContainer">
                <!-- Word categories and buttons will be dynamically loaded here -->
            </div>
        </div>
    </div> <!-- End of app-container -->

    <!-- Custom Modal for Test Functionality -->
    <div id="testModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <p id="modalQuestion">Which word did you hear?</p>
            <div class="modal-buttons">
                <button id="modalOption1"></button>
                <button id="modalOption2"></button>
            </div>
            <p id="modalFeedback" class="feedback-message"></p>
        </div>
    </div>

    <script type="text/javascript">
        // Embedded JSON Data for Minimal Pairs
        const embeddedWordData = [
            {
                "category": "Initial Consonant",
                "subcategories": [
                    {
                        "name": "Differing by Place (where the sound is made)",
                        "contrasts": [
                            {
                                "description": "/p/ vs. /t/",
                                "pairs": [
                                    ["Pan", "Tan"], ["Pin", "Tin"], ["Pot", "Tot"], ["Pick", "Tick"], ["Pale", "Tale"], ["Pat", "Tat"], ["Pill", "Till"], ["Pug", "Tug"], ["Pest", "Test"], ["Pore", "Tore"], ["Pea", "Tea"], ["Pace", "Taste"], ["Pipe", "Type"], ["Pool", "Tool"], ["Pail", "Tail"]
                                ]
                            },
                            {
                                "description": "/b/ vs. /d/",
                                "pairs": [
                                    ["Bat", "Dat"], ["Big", "Dig"], ["Bell", "Dell"], ["Buy", "Dye"], ["Back", "Dack"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /k/",
                                "pairs": [
                                    ["Pat", "Cat"], ["Pool", "Cool"], ["Pear", "Care"], ["Page", "Cage"]
                                ]
                            },
                            {
                                "description": "/m/ vs. /n/",
                                "pairs": [
                                    ["Mat", "Nat"], ["Me", "Knee"], ["Might", "Night"], ["Met", "Net"]
                                ]
                            },
                            {
                                "description": "/f/ vs. /s/",
                                "pairs": [
                                    ["Fin", "Sin"], ["Fan", "San"], ["Fast", "Sass"], ["Fox", "Socks"]
                                ]
                            },
                            {
                                "description": "/z/ vs. /dʒ/",
                                "pairs": [
                                    ["zest", "jest"], ["zeal", "jail"]
                                ]
                            },                           
                            {
                                "description": "/ʃ/ vs. /s/",
                                "pairs": [
                                    ["Sheep", "Seep"], ["Shun", "Sun"], ["Shame", "Same"], ["Shin", "Sin"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Voicing (vocal cords vibrating or not)",
                        "contrasts": [
                            {
                                "description": "/p/ vs. /b/",
                                "pairs": [
                                    ["Pat", "Bat"], ["Pig", "Big"], ["Pin", "Bin"], ["Pie", "Buy"], ["Pit", "Bit"]
                                ]
                            },
                            {
                                "description": "/t/ vs. /d/",
                                "pairs": [
                                    ["To", "Do"], ["Tip", "Dip"], ["Ten", "Den"], ["Tie", "Die"]
                                ]
                            },
                            {
                                "description": "/k/ vs. /g/",
                                "pairs": [
                                    ["Cat", "Gat"], ["Cut", "Gut"], ["Kiss", "Guess"], ["Came", "Game"]
                                ]
                            },
                            {
                                "description": "/f/ vs. /v/",
                                "pairs": [
                                    ["Fan", "Van"], ["Fine", "Vine"], ["Fat", "Vat"], ["Few", "View"]
                                ]
                            },
                            {
                                "description": "/s/ vs. /z/",
                                "pairs": [
                                    ["Seal", "Zeal"], ["Sink", "Zink"], ["Sip", "Zip"]
                                ]
                            },
                            {
                                "description": "/θ/ vs. /ð/",
                                "pairs": [
                                    ["Thin", "Then"], ["Thigh", "Thy"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Manner (how the air flows)",
                        "contrasts": [
                            {
                                "description": "/p/ (Stop) vs. /f/ (Fricative)",
                                "pairs": [
                                    ["Pan", "Fan"], ["Pat", "Fat"], ["Pill", "Fill"]
                                ]
                            },
                            {
                                "description": "/d/ (Stop) vs. /n/ (Nasal)",
                                "pairs": [
                                    ["Den", "Nen"], ["Dare", "Nair"]
                                ]
                            },
                            {
                                "description": "/tʃ/ (Affricate) vs. /ʃ/ (Fricative)",
                                "pairs": [
                                    ["Cheer", "Shear"], ["Chip", "Ship"], ["Chop", "Shop"]
                                ]
                            },
                            {
                                "description": "/dʒ/ (Affricate) vs. /z/ (Fricative)",
                                "pairs": [
                                    ["jag", "zag"], ["jeep", "zeep"], ["jest", "zest"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Final Consonant",
                "subcategories": [
                    {
                        "name": "Differing by Voicing",
                        "contrasts": [
                            {
                                "description": "/t/ vs. /d/ (Alveolar Stop)",
                                "pairs": [
                                    ["Beat", "Bead"], ["Hat", "Had"], ["Sit", "Sid"], ["Pat", "Pad"], ["Bet", "Bed"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /b/ (Bilabial Stop)",
                                "pairs": [
                                    ["Cap", "Cab"], ["Rip", "Rib"], ["Tap", "Tab"]
                                ]
                            },
                            {
                                "description": "/k/ vs. /g/ (Velar Stop)",
                                "pairs": [
                                    ["Back", "Bag"], ["Lock", "Log"], ["Pick", "Pig"]
                                ]
                            },
                            {
                                "description": "/s/ vs. /z/ (Alveolar Fricative)",
                                "pairs": [
                                    ["Peace", "Peas"], ["Race", "Raise"], ["Bus", "Buzz"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Place",
                        "contrasts": [
                            {
                                "description": "/m/ vs. /n/ (Nasal)",
                                "pairs": [
                                    ["Swim", "Swin"], ["Team", "Teen"]
                                ]
                            },
                            {
                                "description": "/n/ vs. /ŋ/ (Alveolar vs. Velar Nasal)",
                                "pairs": [
                                    ["Sin", "Sing"], ["Ran", "Rang"], ["Win", "Wing"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Differing by Manner",
                        "contrasts": [
                            {
                                "description": "/t/ (Stop) vs. /s/ (Fricative)",
                                "pairs": [
                                    ["Hat", "Hass"], ["Pat", "Pass"]
                                ]
                            },
                            {
                                "description": "/d/ (Stop) vs. /z/ (Fricative)",
                                "pairs": [
                                    ["Aid", "Aze"], ["Bid", "Biz"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Vowels",
                "subcategories": [
                    {
                        "name": "Short vs. Long/Tense Vowels",
                        "contrasts": [
                            {
                                "description": "/ɪ/ (short i) vs. /iː/ (long e)",
                                "pairs": [
                                    ["Bin", "Bean"], ["Fit", "Feet"], ["Lip", "Leap"], ["Sip", "Seep"], ["Dill", "Deal"]
                                ]
                            },
                            {
                                "description": "/æ/ (short a) vs. /ɑː/ (broad a)",
                                "pairs": [
                                    ["Cat", "Cart"], ["Bad", "Bard"]
                                ]
                            },
                            {
                                "description": "/ʊ/ (short u) vs. /uː/ (long oo)",
                                "pairs": [
                                    ["Look", "Luke"], ["Pull", "Pool"], ["Should", "Shooed"]
                                ]
                            },
                            {
                                "description": "/ɛ/ (short e) vs. /eɪ/ (long a)",
                                "pairs": [
                                    ["Met", "Mate"], ["Wet", "Wait"], ["Sell", "Sail"], ["Bed", "Bade"]
                                ]
                            },
                            {
                                "description": "/ʌ/ (short u as in 'cut') vs. /ɔː/ (aw as in 'caught')",
                                "pairs": [
                                    ["Cut", "Caught"], ["Duck", "Dock"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Front vs. Back Vowels",
                        "contrasts": [
                            {
                                "description": "/iː/ (long e) vs. /uː/ (long oo)",
                                "pairs": [
                                    ["Feel", "Fool"], ["Leave", "Looze"]
                                ]
                            },
                            {
                                "description": "/æ/ (short a) vs. /ɑː/ (broad a)",
                                "pairs": [
                                    ["Cab", "Cob"], ["Cat", "Cot"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Monophthongs vs. Diphthongs",
                        "contrasts": [
                            {
                                "description": "/ɑː/ (broad a) vs. /aɪ/ (long i)",
                                "pairs": [
                                    ["Dad", "Died"], ["Cop", "Cope"]
                                ]
                            },
                            {
                                "description": "/ɔː/ (aw) vs. /oʊ/ (long o)",
                                "pairs": [
                                    ["Cot", "Coat"], ["Not", "Note"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Consonant Clusters",
                "subcategories": [
                    {
                        "name": "Initial Clusters",
                        "contrasts": [
                            {
                                "description": "/s/ vs. /st/",
                                "pairs": [
                                    ["Sit", "Stir"], ["Sip", "Stripe"]
                                ]
                            },
                            {
                                "description": "/l/ vs. /sl/",
                                "pairs": [
                                    ["Led", "Sled"], ["Light", "Slight"]
                                ]
                            },
                            {
                                "description": "/p/ vs. /sp/",
                                "pairs": [
                                    ["Pin", "Spin"], ["Peak", "Speak"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Final Clusters",
                        "contrasts": [
                            {
                                "description": "/mp/ vs. /nt/",
                                "pairs": [
                                    ["Camp", "Cant"], ["Dump", "Dunt"]
                                ]
                            },
                            {
                                "description": "/st/ vs. /sk/",
                                "pairs": [
                                    ["Last", "Lask"], ["Test", "Tesk"]
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "category": "Medial Consonant",
                "subcategories": [
                    {
                        "name": "Voicing",
                        "contrasts": [
                            {
                                "description": "/t/ vs. /d/",
                                "pairs": [
                                    ["Meta", "Medal"], ["City", "Cider"]
                                ]
                            }
                        ]
                    },
                    {
                        "name": "Place",
                        "contrasts": [
                            {
                                "description": "/n/ vs. /m/",
                                "pairs": [
                                    ["Winner", "Whimper"], ["Denim", "Demin"]
                                ]
                            }
                        ]
                    }
                ]
            }
        ];


        var voices = [];
        const synth = window.speechSynthesis; // Re-declare synth for scope

        // Minimal Pair Specific Elements
        const wordButtonsContainer = document.getElementById('wordButtonsContainer');
        const voiceSelect = document.getElementById('voiceSelect'); // This is the primary voice select now

        const textBox1 = document.getElementById('textBox1');
        const textBox2 = document.getElementById('textBox2');
        const speakFirstWordButton = document.getElementById('speakFirstWordButton');
        const speakSecondWordButton = document.getElementById('speakSecondWordButton');
        const speakCustomPairButton = document.getElementById('speakCustomPairButton');
        const testCustomPairButton = document.getElementById('testCustomPairButton');

        const pauseSlider = document.getElementById('pauseSlider');
        const pauseValue = document.getElementById('pauseValue');
        const stickyControls = document.getElementById('stickyControls');
        const mainContentWrapper = document.getElementById('mainContentWrapper');

        // New slider elements
        const pitchSlider = document.getElementById('pitchSlider');
        const pitchValue = document.getElementById('pitchValue');
        const rateSlider = document.getElementById('rateSlider');
        const rateValue = document.getElementById('rateValue');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');


        // Modal elements
        const testModal = document.getElementById('testModal');
        const modalQuestion = document.getElementById('modalQuestion');
        const modalOption1 = document.getElementById('modalOption1');
        const modalOption2 = document.getElementById('modalOption2');
        const modalFeedback = document.getElementById('modalFeedback');

        let currentPauseDurationMs = parseInt(pauseSlider.value);
        let correctWord = ''; // Variable to store the correct word for the test

        // Flag to manage speech state for minimal pairs
        let isSpeechInProgress = false;

        function populateVoiceList() {
          voices = synth.getVoices().sort((a, b) => {
              const aname = a.name.toUpperCase();
              const bname = b.name.toUpperCase();
              if (aname < bname) return -1;
              if (aname > bname) return +1;
              return 0;
          });

          voiceSelect.innerHTML = ''; // Clear minimal pair voice select

          if (voices.length === 0) {
              console.warn("No voices available. This might be due to browser limitations or voices not being loaded yet.");
              voiceSelect.innerHTML = '<option value="">No Voices Available</option>';
              return;
          }

          let defaultVoiceFound = false;

          for (var i = 0; i < voices.length; i++) {
            var option = document.createElement('option');
            option.textContent = `${voices[i].name} (${voices[i].lang})`;
            option.setAttribute('data-index', i); // Store index for minimal pair logic

            if (voices[i].default || (voices[i].lang === 'en-US' && !defaultVoiceFound)) {
              option.selected = true;
              defaultVoiceFound = true;
            }
            voiceSelect.appendChild(option);
          }

          // Fallback if no default or en-US voice was found
          if (!defaultVoiceFound && voices.length > 0) {
              voiceSelect.options[0].selected = true;
          }
          console.log("Voice list populated. Total voices:", voices.length);
        }

        populateVoiceList();
        if (synth.onvoiceschanged !== undefined)
          synth.onvoiceschanged = populateVoiceList;

        // Helper function to get the selected voice for minimal pairs
        function getSelectedVoiceForMinimalPairs() {
            const selectedIndex = voiceSelect.selectedIndex;
            return voices[selectedIndex]; // Use the global 'voices' array
        }

        // Helper function to wait for speech to stop (re-using main script's synth.cancel)
        async function waitForSpeechToStopMinimalPairs() {
            if (synth.speaking) {
                synth.cancel();
            }
            while (synth.speaking) {
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            isSpeechInProgress = false;
        }

        // Speak function for minimal pairs
        async function speakWordMinimalPairs(word) {
            return new Promise(async (resolve) => {
                await waitForSpeechToStopMinimalPairs();

                isSpeechInProgress = true;

                const utterance = new SpeechSynthesisUtterance(word);
                utterance.voice = getSelectedVoiceForMinimalPairs();
                utterance.pitch = parseFloat(pitchSlider.value); // Use value from slider
                utterance.rate = parseFloat(rateSlider.value);   // Use value from slider
                utterance.volume = parseFloat(volumeSlider.value); // Use value from slider

                utterance.onend = () => {
                    isSpeechInProgress = false;
                    resolve();
                };
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror (Minimal Pairs)', event.error, `Word: "${word}"`);
                    isSpeechInProgress = false;
                    resolve();
                };

                try {
                    if (utterance.voice) {
                        synth.speak(utterance);
                    } else {
                        console.warn("No valid voice selected for minimal pair speech, cannot speak.");
                        isSpeechInProgress = false;
                        resolve();
                    }
                } catch (e) {
                    console.error("Error calling speechSynthesis.speak (Minimal Pairs):", e);
                    isSpeechInProgress = false;
                    resolve();
                }
            });
        }

        async function speakPairMinimalPairs(word1, word2) {
            await speakWordMinimalPairs(word1);
            await new Promise(resolve => setTimeout(resolve, currentPauseDurationMs));
            await speakWordMinimalPairs(word2);
        }

        async function speakRepeatedlyMinimalPairs(word, count) {
            for (let i = 0; i < count; i++) {
                await speakWordMinimalPairs(word);
                if (i < count - 1) {
                    await new Promise(resolve => setTimeout(resolve, currentPauseDurationMs));
                }
            }
        }

        // Function to show the test modal
        function showTestModalMinimalPairs(pair) {
            modalOption1.textContent = pair[0];
            modalOption2.textContent = pair[1];
            modalFeedback.textContent = ''; // Clear previous feedback
            modalFeedback.className = 'feedback-message'; // Reset class
            modalOption1.style.display = ''; // Ensure buttons are visible
            modalOption2.style.display = ''; // Ensure buttons are visible
            testModal.style.display = 'flex'; // Show the modal
        }

        // Function to check the user's answer
        function checkAnswerMinimalPairs(userAnswer) {
            if (userAnswer === correctWord) {
                modalFeedback.textContent = 'Correct!';
                modalFeedback.classList.add('correct');
            } else {
                modalFeedback.textContent = `Wrong! It was "${correctWord}".`;
                modalFeedback.classList.add('wrong');
            }
            // Hide modal after a short delay
            setTimeout(() => {
                testModal.style.display = 'none';
                modalFeedback.textContent = ''; // Clear feedback for next test
            }, 2000);
        }

        // Event listeners for modal buttons
        modalOption1.addEventListener('click', () => checkAnswerMinimalPairs(modalOption1.textContent));
        modalOption2.addEventListener('click', () => checkAnswerMinimalPairs(modalOption2.textContent));

        function generateButtons(wordData) {
            wordButtonsContainer.innerHTML = '';
            if (!wordData || wordData.length === 0) {
                wordButtonsContainer.innerHTML = '<p>No word data available.</p>';
                return;
            }

            wordData.forEach(categoryObj => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category-container';
                categoryDiv.innerHTML = `<h2>${categoryObj.category}</h2>`;
                wordButtonsContainer.appendChild(categoryDiv);

                const subcategoryArray = categoryObj.subcategories || [];

                subcategoryArray.forEach(subcategoryObj => {
                    const subcategoryDiv = document.createElement('div');
                    subcategoryDiv.className = 'subcategory-container';
                    if (subcategoryObj.name) {
                        subcategoryDiv.innerHTML = `<h3>${subcategoryObj.name}</h3>`;
                    }
                    categoryDiv.appendChild(subcategoryDiv);

                    if (subcategoryObj.description) {
                        const descriptionP = document.createElement('p');
                        descriptionP.textContent = subcategoryObj.description;
                        subcategoryDiv.appendChild(descriptionP);
                    }

                    if (subcategoryObj.contrasts && subcategoryObj.contrasts.length > 0) {
                        subcategoryObj.contrasts.forEach(contrastObj => {
                            const contrastGroupDiv = document.createElement('div');
                            contrastGroupDiv.className = 'contrast-group';
                            const contrastTitle = document.createElement('h4');
                            contrastTitle.textContent = `Contrast: ${contrastObj.description}`;
                            contrastGroupDiv.appendChild(contrastTitle);
                            subcategoryDiv.appendChild(contrastGroupDiv);

                            contrastObj.pairs.forEach(pair => {
                                const pairSectionDiv = document.createElement('div');
                                pairSectionDiv.className = 'pair-section';

                                const pairLabel = document.createElement('span');
                                pairLabel.className = 'pair-label';
                                pairLabel.textContent = `${pair[0]} vs. ${pair[1]}`;
                                pairSectionDiv.appendChild(pairLabel);

                                const buttonPairDiv = document.createElement('div');
                                buttonPairDiv.className = 'button-pair';

                                const button1 = document.createElement('button');
                                button1.textContent = pair[0];
                                button1.setAttribute('data-word1', pair[0]);
                                button1.addEventListener('click', () => speakWordMinimalPairs(pair[0]));
                                buttonPairDiv.appendChild(button1);

                                const button2 = document.createElement('button');
                                button2.textContent = pair[1];
                                button2.setAttribute('data-word2', pair[1]);
                                button2.addEventListener('click', () => speakWordMinimalPairs(pair[1]));
                                buttonPairDiv.appendChild(button2);

                                const speakPairButton = document.createElement('button');
                                speakPairButton.textContent = "Listen Pair";
                                speakPairButton.className = "listen-pair";
                                speakPairButton.setAttribute('data-word-pair-1', pair[0]);
                                speakPairButton.setAttribute('data-word-pair-2', pair[1]);
                                speakPairButton.addEventListener('click', () => speakPairMinimalPairs(pair[0], pair[1]));
                                buttonPairDiv.appendChild(speakPairButton);

                                const testButton = document.createElement('button');
                                testButton.textContent = 'Test';
                                testButton.className = 'test-pair';
                                testButton.addEventListener('click', async () => {
                                    const randomIndex = Math.floor(Math.random() * pair.length);
                                    correctWord = pair[randomIndex];
                                    await speakRepeatedlyMinimalPairs(correctWord, 3);
                                    showTestModalMinimalPairs(pair);
                                });
                                buttonPairDiv.appendChild(testButton);

                                pairSectionDiv.appendChild(buttonPairDiv);
                                contrastGroupDiv.appendChild(pairSectionDiv);
                            });
                        });
                    }
                });
            });
        }

        // --- Event Listeners for custom text boxes/buttons (Minimal Pairs) ---
        speakFirstWordButton.addEventListener('click', () => {
            speakWordMinimalPairs(textBox1.value);
        });

        speakSecondWordButton.addEventListener('click', () => {
            speakWordMinimalPairs(textBox2.value);
        });

        speakCustomPairButton.addEventListener('click', () => {
            speakPairMinimalPairs(textBox1.value, textBox2.value);
        });

        testCustomPairButton.addEventListener('click', async () => {
            const pair = [textBox1.value, textBox2.value];
            if (!pair[0] || !pair[1]) {
                testModal.style.display = 'flex';
                modalQuestion.textContent = "Please enter both words in the text boxes to use the Test feature.";
                modalOption1.style.display = 'none';
                modalOption2.style.display = 'none';
                modalFeedback.textContent = '';
                setTimeout(() => {
                    testModal.style.display = 'none';
                    modalOption1.style.display = '';
                    modalOption2.style.display = '';
                }, 3000);
                return;
            }
            const randomIndex = Math.floor(Math.random() * pair.length);
            correctWord = pair[randomIndex];

            await speakRepeatedlyMinimalPairs(correctWord, 3);
            showTestModalMinimalPairs(pair);
        });

        // --- Event Listeners for Pitch, Rate, Volume Sliders ---
        pitchSlider.addEventListener('input', () => {
            pitchValue.textContent = parseFloat(pitchSlider.value).toFixed(1);
        });
        rateSlider.addEventListener('input', () => {
            rateValue.textContent = parseFloat(rateSlider.value).toFixed(1);
        });
        volumeSlider.addEventListener('input', () => {
            volumeValue.textContent = parseFloat(volumeSlider.value).toFixed(1);
        });

        // Reset functions for sliders
        function resetPitch() {
            pitchSlider.value = 1;
            pitchValue.textContent = '1.0';
        }
        function resetRate() {
            rateSlider.value = 1;
            rateValue.textContent = '1.0';
        }
        function resetVolume() {
            volumeSlider.value = 1;
            volumeValue.textContent = '1.0';
        }

        // --- Event Listener for Pause Slider ---
        pauseSlider.addEventListener('input', () => {
            currentPauseDurationMs = parseInt(pauseSlider.value);
            pauseValue.textContent = (currentPauseDurationMs / 1000).toFixed(1) + " sec";
        });

        // Event Delegation for Dynamically Generated Buttons
        wordButtonsContainer.addEventListener('click', (event) => {
            const target = event.target;
            if (target.tagName === 'BUTTON') {
                // Single word buttons
                if (target.hasAttribute('data-word1') && !target.classList.contains('listen-pair') && !target.classList.contains('test-pair')) {
                    speakWordMinimalPairs(target.getAttribute('data-word1'));
                } else if (target.hasAttribute('data-word2') && !target.classList.contains('listen-pair') && !target.classList.contains('test-pair')) {
                    speakWordMinimalPairs(target.getAttribute('data-word2'));
                }
            }
        });

        // Initial call to generate minimal pair buttons when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            generateButtons(embeddedWordData);
        });

    </script>
  </body>
</html>
